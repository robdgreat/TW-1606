<HTML>
<HEAD>
  <TITLE>TWX Proxy Script Reference</TITLE>
  <meta content="ElderProphet <ElderProphet@comcast.net>" name="Developer">
</HEAD>
<BODY FACE="Arial">
  <CENTER><H1>TWX Proxy Script Reference v2.04</H1></CENTER><BR><BR>
  <FONT FACE="Arial">Welcome to the TWX Proxy script reference.  This document is designed specially for programmers, scripters, or just people that want to learn TWX Proxy a little better.  Unfortunately there is currently no specification detailing language syntax or the internals of how things actually work, although easily the best way of learning this is to just read over the open source pack1 scripts or the unencrypted portions of the pack2 scripts and see how they work.</FONT><BR><BR><BR>
<H2>Contents</H2><BR><BR>
<H3>Script Commands</H3><font>Many of these commands exist only for internal use or backwards compatibility.</font><br><br>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_1">add</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_2">addMenu</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_3">and</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_4">branch</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_92">clearAllAvoids</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_93">clearAvoid</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_5">clientMessage</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_6">closeMenu</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_7">connect</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_8">cutText</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_9">delete</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_10">disconnect</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_11">divide</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_12">echo</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_13">fileExists</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_94">getAllCourses</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_14">getCharCode</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_15">getConsoleInput</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_16">getCourse</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_17">getDate</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_18">getDistance</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_95">getFileList</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_19">getInput</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_20">getLength</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_21">getMenuValue</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_96">getNearestWarps</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_22">getOutText</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_23">getRnd</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_97">getScriptVersion</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_24">getSector</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_89">getSectorParameter</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_25">getText</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_26">getTime</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_91">getTimer</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_27">getWord</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_28">getWordPos</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_29">gosub</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_30">goto</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_31">halt</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_32">isEqual</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_33">isGreater</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_34">isGreaterEqual</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_35">isLesser</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_36">isLesserEqual</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_37">isNotEqual</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_38">isNumber</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_39">killAllTriggers</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_40">killTrigger</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_41">killWindow</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_98">listActiveScripts</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_99">listAvoids</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_100">listSectorParameters</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_42">load</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_43">loadVar</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_44">logging</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_45">lowerCase</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_46">mergeText</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_47">multiply</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_48">openMenu</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_49">or</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_50">pause</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_51">processIn</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_52">processOut</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_53">read</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_90">readToArray</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_54">rename</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_55">replaceText</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_56">reqRecording</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_57">return</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_87">round</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_58">saveVar</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_59">send</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_60">setArray</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_101">setAvoid</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_61">setDelayTrigger</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_62">setEventTrigger</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_85">setMenuHelp</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_64">setMenuOptions</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_63">setMenuValue</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_86">setPrecision</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_65">setProgVar</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_88">setSectorParameter</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_66">setTextLineTrigger</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_67">setTextOutTrigger</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_68">setTextTrigger</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_69">setVar</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_70">setWindowContents</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_71">sound</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_72">stop</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_73">stripText</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_74">subtract</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_79">systemScript</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_80">upperCase</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_81">waitFor</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_82">window</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_83">write</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#CMD_84">xor</A><BR>
<H3>Script Macros</H3><font>Do not confuse script macros with commands.  Although they are used in the same way, they differ on a technical level.  These macros basically act as a substitute for groups of commands.  They are a quick and easy way to write powerful scripts.</font><br><br>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MACRO_62">IF</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MACRO_63">INCLUDE</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MACRO_64">WAITON</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MACRO_61">WHILE</A><BR>
<H3>System Values</H3><font>The system values can be accessed from anywhere in a script simply by using their name.  Their values will change depending upon the environment.<BR><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_123">ALPHACENTAURI</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_1">ANSI_0</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_2">ANSI_1</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_11">ANSI_10</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_12">ANSI_11</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_13">ANSI_12</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_14">ANSI_13</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_15">ANSI_14</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_16">ANSI_15</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_3">ANSI_2</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_4">ANSI_3</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_5">ANSI_4</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_6">ANSI_5</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_7">ANSI_6</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_8">ANSI_7</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_9">ANSI_8</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_10">ANSI_9</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_17">CONNECTED</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_18">CURRENTANSILINE</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_121">CURRENTLINE</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_124">CURRENTSECTOR</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_19">DATE</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_20">FALSE</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_21">GAME</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_22">GAMENAME</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_23">LICENSENAME</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_24">LOGINNAME</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_25">PASSWORD</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_125">PORT.BUILDTIME</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_29">PORT.BUYEQUIP[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_27">PORT.BUYFUEL[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_28">PORT.BUYORG[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_26">PORT.CLASS[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_32">PORT.EQUIP[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_120">PORT.EXISTS[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_30">PORT.FUEL[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_119">PORT.NAME[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_31">PORT.ORG[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_35">PORT.PERCENTEQUIP[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_33">PORT.PERCENTFUEL[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_34">PORT.PERCENTORG[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_126">PORT.UPDATED</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_127">RAWPACKET</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_122">RYLOS</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_118">SECTOR.ANOMOLY[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_36">SECTOR.BACKDOORCOUNT[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_37">SECTOR.BACKDOORS[sector][index]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_128">SECTOR.BEACON</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_129">SECTOR.CONSTELLATION</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_38">SECTOR.DENSITY[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_39">SECTOR.EXPLORED[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_40">SECTOR.FIGS.OWNER[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_130">SECTOR.FIGS.TYPE</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_41">SECTOR.FIGS.QUANTITY[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_42">SECTOR.LIMPETS.OWNER[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_43">SECTOR.LIMPETS.QUANTITY[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_44">SECTOR.MINES.OWNER[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_45">SECTOR.MINES.QUANTITY[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_46">SECTOR.NAVHAZ[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_47">SECTOR.PLANETCOUNT[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_48">SECTOR.PLANETS[sector][index]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_49">SECTOR.SHIPCOUNT[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_51">SECTOR.SHIPS[sector][index]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_50">SECTOR.TRADERCOUNT[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_52">SECTOR.TRADERS[sector][index]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_117">SECTOR.UPDATED[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_53">SECTOR.WARPCOUNT[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_56">SECTOR.WARPINCOUNT[sector]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_55">SECTOR.WARPSIN[sector][index]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_54">SECTOR.WARPS[sector][index]</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_57">SECTORS</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_58">STARDOCK</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_59">TIME</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#VAL_60">TRUE</A><BR>
<H3>Terminal Menu References</H3><font>The terminal menu references are the names of the built-in TWX Terminal Menus.  These menus can be accessed using the menu scripting commands (addMenu, setMenuValue, getMenuValue, etc)</font><br><br>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_78">TWX_ACCEPTEXTERNAL</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_74">TWX_BUBBLESIZE</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_81">TWX_BURST</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_79">TWX_CACHE</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_84">TWX_CONNECT</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_67">TWX_DATA</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_70">TWX_DATABASE</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_112">TWX_DATABASE_CREATE</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_114">TWX_DATABASE_DELETE</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_113">TWX_DATABASE_EDIT</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_115">TWX_DATABASE_SELECT</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_116">TWX_DATABASE_VIEW</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_92">TWX_DUMPSCRIPTVARS</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_83">TWX_EDITBURST</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_88">TWX_EXIT</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_103">TWX_HOLOSCAN</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_95">TWX_KILL</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_93">TWX_LISTACTIVE</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_94">TWX_LISTDIRECTORY</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_73">TWX_LISTENPORT</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_110">TWX_LISTPORTS</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_111">TWX_LISTUPGRADEDPORTS</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_90">TWX_LOADLASTSCRIPT</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_89">TWX_LOADSCRIPT</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_80">TWX_LOCALECHO</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_76">TWX_LOG</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_77">TWX_LOGANSI</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_65">TWX_MAIN</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_102">TWX_PLOTCOURSE</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_68">TWX_PORT</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_75">TWX_RECONNECT</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_82">TWX_REPEATBURST</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_66">TWX_SCRIPT</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_72">TWX_SCRIPTKEY</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_71">TWX_SCRIPTTEXT</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_69">TWX_SETUP</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_100">TWX_SHOWANOM</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_107">TWX_SHOWBACKDOORS</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_106">TWX_SHOWBUBBLE</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_105">TWX_SHOWBUBBLES</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_87">TWX_SHOWCLIENTS</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_99">TWX_SHOWDENSITY</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_97">TWX_SHOWFIGS</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_98">TWX_SHOWMINES</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_108">TWX_SHOWPORT</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_96">TWX_SHOWSECTOR</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_109">TWX_SHOWSPECIALPORT</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_101">TWX_SHOWTRADERS</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_91">TWX_STOPALL</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_86">TWX_STOPALLFAST</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_85">TWX_TOGGLEDEAF</A><BR>
&nbsp;&nbsp;&nbsp;<A HREF="script.html#MENU_104">TWX_TOTALSCANNED</A><BR>
<BR><BR>
<HR><CENTER><H2>Script Commands</H2></CENTER><HR>
<A NAME="CMD_1"><H3>add</H3><BR><BR>
<FONT><B>Purpose:</B> Adds a value to a variable.</FONT><BR><BR>
<FONT><B>Syntax:</B> add var {value} <BR>
<BR>
var: The variable that will have its value added to.<BR>
<BR>
{value}: The amount the variable will be increased by (must be a number).<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command is a typical way to perform basic mathematics within TWX script.<BR>
<BR>
Since mathematical and logical operators were introduced in v2.00, it is also possible to
add to a variable using the following method:<BR>
<BR>
setVar $value ($value + 1)</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># calculate exactly how many trips we're making
# and how much we're carrying on our last trip

setVar $trips $quantity
divide $trips $holds
setVar $x $trips
multiply $x $holds
setVar $lastTrip $quantity
subtract $lastTrip $x
if ($lastTrip = 0)
  setVar $lastTrip $holds
else
  add $trips 1
end

</PRE></FONT><BR><BR><HR>
<A NAME="CMD_2"><H3>addMenu</H3><BR><BR>
<FONT><B>Purpose:</B> Adds a new TWX menu.  This menu can be either an internal script menu or an addition to the
TWX Terminal Menu.</FONT><BR><BR>
<FONT><B>Syntax:</B> addMenu {parent} {name} {description} {hotkey} {reference} {prompt} {closeMenu} <BR>
<BR>
{parent}: The name of the 'parent' menu this menu will be added to.  If left blank, the menu
will not be shown in the option list of any other menu in existance.<BR>
<BR>
{name}: The name of the new menu being created.<BR>
<BR>
{description}: The description of the menu being created.  This description will be shown
in the option list of the parent menu, and as a title for the new menu option list.<BR>
<BR>
{hotkey}: The hotkey used to access this menu from it's parent menu.<BR>
<BR>
{reference}: The script label reference to jump to when the new menu is activated.<BR>
<BR>
{prompt}: The text to display inside the new menu prompt.<BR>
<BR>
{closeMenu}: If TRUE, this menu will automatically close itself when it is activated.  For
sub-menus that contain their own list of options, this should always be set to FALSE.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> TWX menus are a great way to configure scripts before they are run.  Also, using this command
it is possible to customise the TWX Terminal Menu and add your own options.<BR>
<BR>
Every menu can have a near limitless number of options, and every option can link to a new
menu.<BR>
<BR>
Menus can be activated using the 'OpenMenu' command after they have been created.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE>addMenu "" "BuyDown" "BuyDown Settings" "." "" "Main" FALSE
addMenu "BuyDown" "GO" "GO!" "G" :Menu_Go "" TRUE
addMenu "BuyDown" "Product" "Product" "P" :Menu_Product "" FALSE
addMenu "BuyDown" "TurnLimit" "Turn limit" "T" :Menu_TurnLimit "" FALSE
addMenu "BuyDown" "Quantity" "Quantity" "U" :Menu_Quantity "" FALSE
addMenu "BuyDown" "Haggle" "Haggling" "H" :Menu_HaggleFactor "" FALSE

gosub :sub_SetMenu

openMenu "BuyDown"
</PRE></FONT><BR><BR><HR>
<A NAME="CMD_3"><H3>and</H3><BR><BR>
<FONT><B>Purpose:</B> Performs a logical 'AND' on a variable.</FONT><BR><BR>
<FONT><B>Syntax:</B> and var {value} <BR>
<BR>
var: The variable to be operated on.  The value in this variable must be either TRUE (1) or
FALSE (0).<BR>
<BR>
{value}: The value to be operated by.  This value must be either TRUE (1) or FALSE (0).<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command is used internally by the compiler to allow conditions to work properly.  Its
use in conventional scripting is almost unheard of.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_4"><H3>branch</H3><BR><BR>
<FONT><B>Purpose:</B> Tests a value and performs a conditional jump to a script label.</FONT><BR><BR>
<FONT><B>Syntax:</B> branch {value} {label} <BR>
<BR>
{value}: The value to be tested.<BR>
<BR>
{label}: The script label to jump to if the value is FALSE (0)<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command is used internally by the compiler to allow conditions to work properly.  Its
use in conventional scripting is not required in any way - use the 'IF' macro instead.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>

<A NAME="CMD_92"><H3>clearAllAvoids</H3><BR><BR>
<FONT><B>Purpose:</B> Removes all sectors from TWX's internal Avoid list, which is used by getCourse, getDistance,
getNearestWarps, and getAllCourses.</FONT><BR><BR>
<FONT><B>Syntax:</B> clearAllAvoids</FONT><BR><BR>
<FONT><B>Notes:</B> Since all of TWX's plots use the internal Avoid list, it's a good idea to clear any
existing avoids if you do not want them taken into account, or if you are unsure which ones are set.  Be aware that
these Avoids are independant of the game's Avoids.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE>setAvoid $enemySector
getCourse $course CURRENTSECTOR STARDOCK
gosub :mowCourse
clearAllAvoids</PRE></FONT><BR><BR><HR>

<A NAME="CMD_93"><H3>clearAvoid</H3><BR><BR>
<FONT><B>Purpose:</B> Removes a single sector from TWX's internal Avoid list, which is used by getCourse,
getDistance, getNearestWarps, and getAllCourses.</FONT><BR><BR>
<FONT><B>Syntax:</B> clearAvoid {sector}</FONT><BR>
<BR>
{sector}: The sector to remove from the internal Avoid list.<BR>
<BR>
{sector}: The sector number to remove from the internal Avoid list.<BR>
<BR>
<FONT><B>Notes:</B> Be aware that this command only removes Avoids from the internal list, and does not alter the Avoids
set in the game itself.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE>
</PRE></FONT><BR><BR><HR>

<A NAME="CMD_5"><H3>clientMessage</H3><BR><BR>
<FONT><B>Purpose:</B> Broadcast a block of formatted text to all connected telnet terminals.</FONT><BR><BR>
<FONT><B>Syntax:</B> clientMessage {value} <BR>
<BR>
{value}: The message to display to all connected telnet terminals.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command is a slightly bolder version of the 'Echo' command.  It is useful for debugging
or spitting out script messages.  It is unfortunately not very tidy.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># don't run script without free cargo holds
if ($holds = 0)
  clientMessage "No free cargo holds!"
  halt
end</PRE></FONT><BR><BR><HR>
<A NAME="CMD_6"><H3>closeMenu</H3><BR><BR>
<FONT><B>Purpose:</B> Closes the open TWX menu.</FONT><BR><BR>
<FONT><B>Syntax:</B> closeMenu</FONT><BR><BR>
<FONT><B>Notes:</B> This command can be used to close the TWX Terminal Menu, or any other script menu that is
currently open.  Menus can be opened using the 'OpenMenu' command, and created with the 'AddMenu'
command.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_7"><H3>connect</H3><BR><BR>
<FONT><B>Purpose:</B> Connects TWX Proxy to a remote server.</FONT><BR><BR>
<FONT><B>Syntax:</B> connect</FONT><BR><BR>
<FONT><B>Notes:</B> This command is exactly the same as using the 'Connect' option from the TWX Terminal menu.
It will connect TWX Proxy to the game server defined in the currently selected database.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_8"><H3>cutText</H3><BR><BR>
<FONT><B>Purpose:</B> 'Cuts' a value out of a piece of text.</FONT><BR><BR>
<FONT><B>Syntax:</B> cutText {value} var {start} {length} <BR>
<BR>
{value}: The text to 'cut' a value out of.<BR>
<BR>
var: The variable to hold the 'cut' value.<BR>
<BR>
{start}: The starting index of the value to 'cut'.<BR>
<BR>
{length}: The length of the value to 'cut'.  If this length is longer than the end of the
text being 'cut' from, the value will be 'cut' to the end of the text.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command will copy a value out of a larger value.  This is a very useful command when
parsing text.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># get the name of a planet being landed on

getWord CURRENTLINE $ID 2
stripText $ID "#"
getWord CURRENTLINE $Sector 5
stripText $Sector ":"
getWordPos CURRENTLINE $Pos ": "
cutText CURRENTLINE $Name ($Pos + 2) 999</PRE></FONT><BR><BR><HR>
<A NAME="CMD_9"><H3>delete</H3><BR><BR>
<FONT><B>Purpose:</B> Deletes a file.</FONT><BR><BR>
<FONT><B>Syntax:</B> delete {filename} <BR>
<BR>
{filename}: The name of the file to be deleted.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command will immediately delete the specified file.  If the file does not exist, no error
will be given.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># write dead-end list to a file

clientMessage "Querying..."
delete deadends.txt
setVar $i 1
:next

if (SECTOR.WARPS[$i][2] = 0)
  write "deadends.txt" $i
end
if ($i > SECTORS)
  halt
end
add $i 1
goto :next</PRE></FONT><BR><BR><HR>
<A NAME="CMD_10"><H3>disconnect</H3><BR><BR>
<FONT><B>Purpose:</B> Disconnects TWX Proxy from the remote server.</FONT><BR><BR>
<FONT><B>Syntax:</B> disconnect</FONT><BR><BR>
<FONT><B>Notes:</B> This command will immediately disconnect from the remote server.  No reconnect will be attempted.
This is exactly the same as using the 'Disconnect' option from the TWX Terminal Menu.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_11"><H3>divide</H3><BR><BR>
<FONT><B>Purpose:</B> Performs mathematical division on a variable.</FONT><BR><BR>
<FONT><B>Syntax:</B> divide var {value} <BR>
<BR>
var: The variable to be divided.<BR>
<BR>
{value}: The amount to divide the variable by.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command is used internally by the compiler to perform division.  It can also be called
manually.<BR>
<BR>
Note that all decimal values will be truncated to the nearest whole number.<BR>
<BR>
Another way to perform division is like this:<BR>
<BR>
setVar $value ($value / 50)</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># calculate exactly how many trips we're making
# and how much we're carrying on our last trip

setVar $trips $quantity
divide $trips $holds
setVar $x $trips
multiply $x $holds
setVar $lastTrip $quantity
subtract $lastTrip $x
if ($lastTrip = 0)
  setVar $lastTrip $holds
else
  add $trips 1
end</PRE></FONT><BR><BR><HR>
<A NAME="CMD_12"><H3>echo</H3><BR><BR>
<FONT><B>Purpose:</B> Prints text to all connected telnet terminals.</FONT><BR><BR>
<FONT><B>Syntax:</B> echo {values...} <BR>
<BR>
{values...}: A series of values containing the text to be echoed.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command is the primary way of displaying text in connected clients without sending it
to the server.  Using this command, you can output data from your script, create menus, etc.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># Get a product type using a menu

:GetProduct
echo "*" ANSI_15 "Select Product:" "**"
echo ANSI_11 "1 " ANSI_3 " - Fuel Ore*"
echo ANSI_11 "2 " ANSI_3 " - Organics*"
echo ANSI_11 "3 " ANSI_3 " - Equipment*"
getConsoleInput $Product SINGLEKEY

if ($Product <> 1) and ($Product <> 2) and ($Product <> 3)
  goto :GetProduct
end

</PRE></FONT><BR><BR><HR>
<A NAME="CMD_13"><H3>fileExists</H3><BR><BR>
<FONT><B>Purpose:</B> Checks to see if a file exists.</FONT><BR><BR>
<FONT><B>Syntax:</B> fileExists var {filename} <BR>
<BR>
var: The variable to hold the result of the file check.  This variable will be set to TRUE
(1) if the file exists, or FALSE (0) if it does not.<BR>
<BR>
{filename}: The name of the file to check.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command is useful for finding out if a file exists before attempting to read from it.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># load bust list
if ($BustFile <> "")
  fileExists $exists $BustFile

  if ($exists)
    setArray $BustList SECTORS
    setVar $i 1
    read $BustFile $bust $i
    while ($bust <> EOF)
      setVar $BustList[$bust] 1
      add $i 1
      read $BustFile $bust $i
    end
  end
end</PRE></FONT><BR><BR><HR>

<A NAME="CMD_94"><H3>getAllCourses</H3><BR><BR>
<FONT><B>Purpose:</B> Creates a 2-dimensional array with all course plots and distances where the StartSector is
the specified sector, and the EndSector is the 1st dimension index.</FONT><BR><BR>
<FONT><B>Syntax:</B> getAllCourses {array} {sector}</FONT><BR>
<BR>
{array}: The user-specified array to populate, and associated variable which will equal the static array's size.
This need not pre-exist, and any existing values will be overwritten.<BR>
<BR>
{sector}: The starting sector for all of the plots.<BR>
<BR>
<FONT><B>Notes:</B> This is a useful command if you need multiple plots or distances from the same start sector.
This command works comparably to getCourse.  Be aware, the plots that are returned take into account any Avoids
which may have been added to the internal Avoid list by the setAvoid command.<BR>
<BR>If you used this command with StarDock specified as the start sector, the first few array elements would be as follows:<BR>
<BR>$array[1]    = the distance from SD to sector 1
<BR>$array[1][1] = the start sector (StarDock in this example)
<BR>$array[1][2] = the first hop in the course from StarDock to sector1
<BR>$array[1][3] = the second hop, and so on.
<BR>...
<BR>$array[2]    = the distance from SD to sector 2
<BR>$array[2][1] = the start sector (StarDock again)
<BR>$array[2][2] = the first hop in the course from StarDock to sector2
<BR>... and so on.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># Locate all unfigged sectors 8 hops from Terra and show the course
setVar $hops 8
getAllCourses $courses 1
setVar $a 1
while ($a <= SECTORS)
	if ($courses[$a] = $hops) and ($figGrid[$a] = 0)
		echo "*" $a ", Course:"
		setVar $b 1
		while ($b <= ($courses[$a] + 1))
			echo "  " $courses[$a][$b]
			add $b 1
		end
	end
	add $a 1
end</PRE></FONT><BR><BR><HR>

<A NAME="CMD_14"><H3>getCharCode</H3><BR><BR>
<FONT><B>Purpose:</B> Retrieves an ASCII character code from a single-character value.</FONT><BR><BR>
<FONT><B>Syntax:</B> getCharCode {char} resultVar <BR>
<BR>
{char}: The character to get a code from.  This must be a single character, it cannot be a
block of text.<BR>
<BR>
resultVar: A variable to hold the character code.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> For more information on ASCII character conversions, look up 'ASCII chart' in an internet
search engine.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_15"><H3>getConsoleInput</H3><BR><BR>
<FONT><B>Purpose:</B> Get input from a connected terminal without sending it to the remote server.</FONT><BR><BR>
<FONT><B>Syntax:</B> getConsoleInput var [singleKey?] <BR>
<BR>
var: A variable to hold the retreived input.<BR>
<BR>
[singleKey?]: If this is specified, the command will only expect single key input as opposed
to an entire line of text.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command will pause the script until text is received from one of the connected telnet
terminals.  It is a useful way of getting script parameters when a script is first started,
and can also be used to create menus.<BR>
<BR>
Execution of the script will be paused while this command is active.  Closing of the menu
created by the command will terminate the script.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># Get a product type using a menu

:GetProduct
echo "*" ANSI_15 "Select Product:" "**"
echo ANSI_11 "1 " ANSI_3 " - Fuel Ore*"
echo ANSI_11 "2 " ANSI_3 " - Organics*"
echo ANSI_11 "3 " ANSI_3 " - Equipment*"
getConsoleInput $Product SINGLEKEY

if ($Product <> 1) and ($Product <> 2) and ($Product <> 3)
  goto :GetProduct
end

</PRE></FONT><BR><BR><HR>
<A NAME="CMD_16"><H3>getCourse</H3><BR><BR>
<FONT><B>Purpose:</B> Internally calculates a warp course using warp data in the TWX Proxy database.</FONT><BR><BR>
<FONT><B>Syntax:</B> getCourse varspec {fromSector} {toSector} <BR>
<BR>
varspec:  A variable that will contain the results of the course plotting.<BR>
<BR>
{fromSector}:  The sector to plot the course from.<BR>
<BR>
{toSector}:  The sector to plot the course to.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command will plot a warp course without the use of the remote server.  Note that this
can only be done if there is sufficient warp data to properly plot the course.<BR>
<BR>
'varspec' will contain the length (number of hops) of the warp course between the two sectors.
This variable will be transformed into a dynamic array holding in sequence every sector in
the warp course, i.e:<BR>
<BR>
getCourse $course 1 10<BR>
<BR>
Would return:<BR>
<BR>
$course = 2<BR>
$course[1] = 1<BR>
$course[2] = 2<BR>
$course[3] = 10<BR>
<BR>
<BR>
If the warp course could not be calculated, 'varspec' will be set to -1.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># plot and display a warp course

getInput $fromSector "Enter a sector to plot from"
getInput $toSector "Enter a sector to plot to"
getCourse $course $fromSector $toSector

setVar $i 0

while ($i <= course)
  echo $course[$i] " "
  add $i 1
end</PRE></FONT><BR><BR><HR>
<A NAME="CMD_17"><H3>getDate</H3><BR><BR>
<FONT><B>Purpose:</B> Retrieves the date and stores it in a variable.</FONT><BR><BR>
<FONT><B>Syntax:</B> getDate var <BR>
<BR>
var: A variable that will contain the current date.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command will return the date in the current system format.  Note that this date will
vary depending upon your regional settings.  For more flexibility when formatting your date,
refer to the 'getTime' command.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_18"><H3>getDistance</H3><BR><BR>
<FONT><B>Purpose:</B> Internally calculates the distance between two sectors through the use of the TWX Proxy Database.</FONT><BR><BR>
<FONT><B>Syntax:</B> getDistance var {fromSector} {toSector} <BR>
<BR>
var: A variable that will contain the distance between the two sectors.<BR>
<BR>
{fromSector}: The sector to plot a course from.<BR>
<BR>
{toSector}: The sector to plot a course to.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command behaves exactly the same as the 'getCourse' command - it internally plots a warp
course between two sectors.  The difference is that this command will record only the distance
between both sectors without saving the results of the course itself - this gives a marginal
speed improvement.<BR>
<BR>
If there is not enough warp data to plot between the two sectors, 'var' will be set to -1.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>

<A NAME="CMD_95"><H3>getFileList</H3><BR><BR>
<FONT><B>Purpose:</B> Populates a specified array with any files that match a specified Mask (like *.ts).</FONT><BR><BR>
<FONT><B>Syntax:</B> getFileList {array} {Mask}</FONT><BR><BR>
<FONT><B>Notes:</B> This command allows a script to inventory the TWX folder or a subfolder for filenames that match the
Mask's search criteria, using ? and * wildcards as needed.  A variable matching the array name will be created with the
number of files found.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># Search the logs to find any Starports that have been initiated.
getFileList $logs "logs\*" & GAMENAME & ".log"
# if 20 files where found, the variable '$logs' now equals 20.
# $logs[1] is the 1st file name, $logs[2] the 2nd, and so on.
echo "*A total of " $logs " Logs found."
setVar $a 1
while ($a <= $logs)
	echo "**Now Searching file " $logs[$a] "..."
	readToArray "logs\" & $logs[$a] $linesArray
	setVar $b 1
	while ($b <= $linesArray)
		getWordPos $linesArray[$b] $pos "began construction!"
		if ($pos > 0)
			echo "*" $linesArray[$b]
			add $newPortCount 1
		end
		add $b 1
	end
	add $a 1
end
echo "**Complete, " $newPortCount " ports have been logged.*"</PRE></FONT><BR><BR><HR>

<A NAME="CMD_19"><H3>getInput</H3><BR><BR>
<FONT><B>Purpose:</B> Gets a line of text from the user.</FONT><BR><BR>
<FONT><B>Syntax:</B> getInput var {prompt} <BR>
<BR>
var: A variable to hold the line of text entered by the user.<BR>
<BR>
{prompt}: The text to display above the input prompt.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command is similar to getConsoleInput, although it automatically displays a message above
the prompt and has no support for single-key input.<BR>
<BR>
Execution of the script will be paused while this command is active.  Closing of the menu
created by the command will terminate the script.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># input parameters
getInput $sectorNumber2 "Enter other sector to SSM from"
getInput $holds "Enter max holds to steal"</PRE></FONT><BR><BR><HR>
<A NAME="CMD_20"><H3>getLength</H3><BR><BR>
<FONT><B>Purpose:</B> Retrieves the length of a block of text.</FONT><BR><BR>
<FONT><B>Syntax:</B> getLength {text} var <BR>
<BR>
{text}: The text to be tested for its length.<BR>
<BR>
var: A variable to hold the length of the block of text.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This is a simple text parsing command that can be used to get the length of a variable or
a block of text.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_21"><H3>getMenuValue</H3><BR><BR>
<FONT><B>Purpose:</B> Retrieve the display value of an existing menu.</FONT><BR><BR>
<FONT><B>Syntax:</B> getMenuValue {menuName} var <BR>
<BR>
{menuName}: The name of the menu to fetch the value from.<BR>
<BR>
var: A variable to hold the value from the menu.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command will retrieve the display value of a menu that has either been created using
the 'addMenu' command, or is a part of the TWX Terminal Menu.<BR>
<BR>
To set the display value of a menu, use the 'setMenuValue' command.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>

<A NAME="CMD_96"><H3>getNearestWarps</H3><BR><BR>
<FONT><B>Purpose:</B> Populates a specified array with surrounding sectors, sorted by distance.</FONT><BR><BR>
<FONT><B>Syntax:</B> getNearestWarps {array} {sector}</FONT><BR><BR>
<FONT><B>Notes:</B> This command allows for simple Nearest-Item searches, without the need to create and
maintain a breadth-first search structure.  Be aware that this command takes into account any Avoids that
may have been set using setAvoid.  A variable matching the array name will be created with the size of the array,
and the array will not necessarily have a size of Sectors.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># Find the closest figged sector
getNearestWarps $nearArray CURRENTSECTOR
setVar $i 1
while ($i <= $nearArray)
	setVar $focus $nearArray[$i]
	if ($figGrid[$focus] > 0)
		echo "*NearFig: " $i "*"
		return
	end
	add $i 1
end</PRE></FONT><BR><BR><HR>

<A NAME="CMD_22"><H3>getOutText</H3><BR><BR>
<FONT><B>Purpose:</B> Retrieve any outgoing text from TWX Proxy's outgoing buffer.</FONT><BR><BR>
<FONT><B>Syntax:</B> getOutText var <BR>
<BR>
var: A variable to hold the outgoing text.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command is typically used after the triggering of a TextOutTrigger in order to retrieve
the text being sent to the remote server.  In any other situation, the outgoing buffer should
contain no data.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_23"><H3>getRnd</H3><BR><BR>
<FONT><B>Purpose:</B> Generate a random number within a specified range.</FONT><BR><BR>
<FONT><B>Syntax:</B> getRnd var {lowestValue} {highestValue} <BR>
<BR>
var: A variable to hold the random number.<BR>
<BR>
{lowestValue}: The lowest possible value for the generated number.<BR>
<BR>
{highestValue}: The highest possible value for the generated number.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> For a good working example of this command, see 1_Scout.ts.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE>

</PRE></FONT><BR><BR><HR>

<A NAME="CMD_97"><H3>getScriptVersion</H3><BR><BR>
<FONT><B>Purpose:</B> Reports the version of the compiler used for a compiled script. (*.cts)</FONT><BR><BR>
<FONT><B>Syntax:</B> getScriptVersion {filename} var</FONT><BR><BR>
<FONT><B>Notes:</B> TWX Proxy 2.02 scripts report version 1, 2.03Beta reports version 2, 2.03Final reports
version 3, 2.04 reports version 4.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># Check compiled script's version before opening
getScriptVersion "scripts/buydown.cts" $ver
if ($ver <> 4)
	echo "*You need to update the buydown.cts file*"
else
	load "scripts/buydown.cts"
end</PRE></FONT><BR><BR><HR>

<A NAME="CMD_24"><H3>getSector</H3><BR><BR>
<FONT><B>Purpose:</B> Retrieve the details of a specific sector from the TWX Proxy Database.</FONT><BR><BR>
<FONT><B>Syntax:</B> getSector {index} var <BR>
<BR>
{index}: The number of the sector to retrieve.<BR>
<BR>
var: A variable-spec to hold the details of the sector being retrieved.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> The storageVar will be segmented into several new variables by<BR>
<BR>
the use of a decimal point.  These new variables will be as follows:<BR>
<BR>
<BR>
.INDEX<BR>
.BEACON<BR>
.EXPLORED (equal to YES, NO, DENSITY, CALC)<BR>
.CONSTELLATION<BR>
.ARMIDMINES.QUANTITY<BR>
.LIMPETMINES.QUANTITY<BR>
.ARMIDMINES.OWNER<BR>
.LIMPETMINES.OWNER<BR>
.FIGS.QUANTITY<BR>
.FIGS.OWNER<BR>
.FIGS.TYPE (equal to TOLL, OFFENSIVE, DEFENSIVE)<BR>
.UPDATED<BR>
.WARPS<BR>
.DENSITY<BR>
.ANOMOLY (equal to YES, NO)<BR>
.NAVHAZ<BR>
.WARP[1]<BR>
.WARP[2]<BR>
.WARP[3]<BR>
.WARP[4]<BR>
.WARP[5]<BR>
.WARP[6]<BR>
.PORT.NAME<BR>
.PORT.CLASS<BR>
<BR>
.PORT.EXISTS (equal to 1 or 0)<BR>
.PORT.BUILDTIME<BR>
.PORT.PERC_ORE<BR>
.PORT.PERC_ORG<BR>
.PORT.PERC_EQUIP<BR>
.PORT.ORE<BR>
.PORT.ORG<BR>
.PORT.EQUIP<BR>
.PORT.UPDATED<BR>
.PORT.BUY_ORE (equal to YES, NO)<BR>
.PORT.BUY_ORG (equal to YES, NO)<BR>
.PORT.BUY_EQUIP (equal to YES, NO)<BR>
<BR>
.PLANETS<BR>
.PLANET[x] (where x = a number from 1 to .PLANETS)<BR>
<BR>
.TRADERS<BR>
.TRADER[x].NAME (where x = a number from 1 to .TRADERS)<BR>
<BR>
.TRADER[x].SHIPNAME (where x = a number from 1 to .TRADERS)<BR>
.TRADER[x].SHIP (where x = a number from 1 to .TRADERS)<BR>
.TRADER[x].FIGS (where x = a number from 1 to .TRADERS)<BR>
<BR>
.SHIPS<BR>
.SHIP[x].NAME (where x = a number from 1 to .SHIPS)<BR>
.SHIP[x].SHIP (where x = a number from 1 to .SHIPS)<BR>
.SHIP[x].OWNER (where x = a number from 1 to .SHIPS)<BR>
<BR>
.SHIP[x].FIGS (where x = a number from 1 to .SHIPS)<BR>
<BR>
.BACKDOORS[x]<BR>
<BR>
<BR>
They can be referenced by VARIABLE.VALUE, for instance:<BR>
<BR>
$sector.warps<BR>
<BR>
Also, this command will not work with recording disabled, as it<BR>
makes use of the sector database to obtain the information it<BR>
needs.  If this information is not available, the output could be<BR>
misleading</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># write dead-end list to a file

clientMessage "Querying..."
delete deadends.txt
setVar $i 1
:next

getSector $i $i
if ($i.warp[2] = 0)
  write "deadends.txt" $i
end
if ($i > SECTORS)
  halt
end
add $i 1
goto :next</PRE></FONT><BR><BR><HR>
<A NAME="CMD_89"><H3>getSectorParameter</H3><BR><BR>
<FONT><B>Purpose:</B> Retrieves a permanent user specified variable that has been assigned to a sector in the TWX
Database.</FONT><BR><BR>
<FONT><B>Syntax:</B> getSectorParameter {sectorIndex} {parameterName} var<BR>
<BR>
{sectorIndex}: The index of the sector holding the value to retrieve.<BR>
<BR>
{parameterName}: The search name of the value to retrieve.  This can be anything up to 10
characters.<BR>
<BR>
var: A variable to contain the value being retrieved.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command can be used to return a value that has been assigned to a sector using the SetSectorParameter
command.<BR>
<BR>
If the value is not found, nothing ("") is returned.<BR>
<BR>
For more information, refer to the SetSectorParameter command.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># show all sectors that have been marked as enemy territory

setVar $i 1

while ($i <= SECTORS)
  getSectorParameter $i "Owner" $owner

  if ($owner = "Enemy")
    echo $i "*"
  end
end</PRE></FONT><BR><BR><HR>
<A NAME="CMD_25"><H3>getText</H3><BR><BR>
<FONT><B>Purpose:</B> Copies a value out of a line of text by using sub strings.</FONT><BR><BR>
<FONT><B>Syntax:</B> getText {line} var {startValue} {endValue} <BR>
<BR>
{line}: The line of text to copy a value from.<BR>
<BR>
var: A variable to store the value in.<BR>
<BR>
{startValue}: A value within the line of text of which the ending point marks the beginning
of the copied value.<BR>
<BR>
{endValue}: A value within the line of text of which the beginning point marks the end of
the copied value.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command is a quick and easy way to snatch a value out of the CURRENTLINE after a TextLineTrigger
has triggered.  If you know of two blocks of text within the line, you can copy out the area
of text between them using this command.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE>setVar $line "This is a test line to copy text from"
getText $line $value "line to " " text from"

# displays: "copy"
echo $value</PRE></FONT><BR><BR><HR>
<A NAME="CMD_26"><H3>getTime</H3><BR><BR>
<FONT><B>Purpose:</B> Retrieves the current system time, or a formatted value containing the time and/or date.</FONT><BR><BR>
<FONT><B>Syntax:</B> getTime var [{format}] <BR>
<BR>
var: A variable to hold the formatted time or date.<BR>
<BR>
[{format}]: The format in which to return the time/date.  If this is not specified, the variable
will be set to hold the current system time in its default format.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This is an extemely powerful date/time formatting command.<BR>
<BR>
Some components of the 'format' command are:<BR>
<BR>
"d" : Displays the day of the month without a leading zero.<BR>
"dd" : Displays the day of the month with a leading zero.<BR>
"m": Displays the month without a leading zero.<BR>
"mm": Displays the month with a leading zero.<BR>
"yy": Displays a two digit year.<BR>
"yyyy": Displays a four digit year.<BR>
<BR>
"h": Displays the hour without a leading zero.<BR>
"hh": Displays the hour with a leading zero.<BR>
"n": Displays the minute without a leading zero.<BR>
"nn": Displays the minute with a leading zero.<BR>
"s": Displays the second without a leading zero.<BR>
"ss": Displays the second with a leading zero.<BR>
<BR>
"am/pm": Displays "am" or "pm" depending upon the time.<BR>
"a/p": Displays "a" or "p" depending upon the time.<BR>
<BR>
"c": Displays the date in its system date format.<BR>
"t": Displays the time in its system time format.<BR>
<BR>
Any characters within quotes are left as they are (without formatting).  Unidentified components
are simply shown as-is.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE>getTime $test "'The time is :' h:m:s, ' the date is :' d:m:yyyy'"

# displays: The time is : 12:22:28,  the date is : 11:4:2003
echo $test</PRE></FONT><BR><BR><HR>
<A NAME="CMD_91"><H3>getTimer</H3><BR><BR>
<FONT><B>Purpose:</B> Retrieves the Time Stamp Counter (RDTSC), which is the number of CPU ticks since power on.</FONT><BR><BR>
<FONT><B>Syntax:</B> getTimer var</FONT><BR>
<BR>
var: A variable to hold the tick count.<BR>
<BR>
<FONT><B>Notes:</B> The result of this command is a 64-bit Integer.  To measure the duration of an event in seconds, you will need to know the CPU speed in Hz.  To simply compare routines to see which is faster, there is no reason to do the conversion to seconds.  Merely get the duration for the first routine, then for the second routine, and whichever has the smaller number of Ticks for the interval is the faster routine.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE>getTimer $startTicks
# Perform some routine here
getTimer $stopTicks
setVar $durationTicks ($stopTicks - $startTicks)

# Now divide by CPU Hz if you need to convert Ticks to seconds. (2.2 GHz here)
# You will need to set the precision according to your desired accuracy, before dividing.
setPrecision 18
setVar $seconds ($durationTicks / 2200000000)
setPrecision 0
echo "*Time lapse in Seconds: " $seconds "*"</PRE></FONT><BR><BR><HR>
<A NAME="CMD_27"><H3>getWord</H3><BR><BR>
<FONT><B>Purpose:</B> Copies a specific word out of a line of text.</FONT><BR><BR>
<FONT><B>Syntax:</B> getWord {line} var {index} {default} <BR>
<BR>
{line}: A line or block of text to copy a specific word from.<BR>
<BR>
var: A variable to hold the copied word.<BR>
<BR>
{index}: The number of the word to copy, counted from the left of the line.<BR>
<BR>
{default}: <BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command is easily the most heavily used text parsing command available in TWX Script.
It can be used very effectively with a TextLineTrigger.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE>setVar $line "This is a line of text"
getWord $line $word 4

# displays: line
echo $word</PRE></FONT><BR><BR><HR>
<A NAME="CMD_28"><H3>getWordPos</H3><BR><BR>
<FONT><B>Purpose:</B> Finds the location of a value within a block of text.</FONT><BR><BR>
<FONT><B>Syntax:</B> getWordPos {text} storageVar {subString} <BR>
<BR>
{text}: A block of text to find a value in.<BR>
<BR>
storageVar: A variable to hold the location of the value.<BR>
<BR>
{subString}: The value to find.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This is a basic text parsing command that will find a value in a block of text.  If the value
is not found, "storagevar" will be set to "0".<BR>
<BR>
Note that this command is not word specific - you can cut out parts of words or even spaces
with it.  ANY value within the block of text that matches the value searched for will be found.
If there are several matches, only the first one will be returned.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE>setVar $line "This is a line of text"
getWordPos $line $pos "line"

# displays: 11
echo $pos</PRE></FONT><BR><BR><HR>
<A NAME="CMD_29"><H3>gosub</H3><BR><BR>
<FONT><B>Purpose:</B> Temporarily jumps to a block of code (or subroutine) with the ability to return to where it
came from.</FONT><BR><BR>
<FONT><B>Syntax:</B> gosub {label} <BR>
<BR>
{label}: A label within the script to temporarily jump to.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command works the same way as a "goto" command, although it has the ability to be sent
back to where it came from through the use of a "return" command.<BR>
<BR>
It is good practice to always make sure that you match every "gosub" with a "return".  Otherwise,
you could get a large build-up of subroutine calls that will eventually cause a stack overflow.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># gosub/return demo:

echo "This is a gosub/return demo.  I'm going to branch to a subroutine."
gosub :subroutine
echo "I've just returned from my subroutine"
halt

:subroutine
echo "I'm in my subroutine"
return</PRE></FONT><BR><BR><HR>
<A NAME="CMD_30"><H3>goto</H3><BR><BR>
<FONT><B>Purpose:</B> Jumps to a different area within the script.</FONT><BR><BR>
<FONT><B>Syntax:</B> goto {label} <BR>
<BR>
{label}: A label within the script to jump to.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command will immediately jump execution of the script to a label anywhere within the
script or its included routines.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># Goto example:

echo "About to jump to another part of my script"
goto :otherPart
echo "I should never execute this command"

:otherPart
echo "I've just jumped to a different part of my script"
halt</PRE></FONT><BR><BR><HR>
<A NAME="CMD_31"><H3>halt</H3><BR><BR>
<FONT><B>Purpose:</B> Immediately and unconditionally terminates the script.</FONT><BR><BR>
<FONT><B>Syntax:</B> halt</FONT><BR><BR>
<FONT><B>Notes:</B> This command will shut down the script immediately.  All unsaved variables are lost, and all
triggers are deactivated.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_32"><H3>isEqual</H3><BR><BR>
<FONT><B>Purpose:</B> Compares two values to see if they are equal.</FONT><BR><BR>
<FONT><B>Syntax:</B> isEqual var {value1} {value2} <BR>
<BR>
var: A variable to hold the result of the comparison.<BR>
<BR>
{value1}: A value to compare.<BR>
<BR>
{value2}: A value to be compared with "value1".<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> "var" will be set to TRUE (1) if the values match, or FALSE (0) if they don't.<BR>
<BR>
This command is used internally by the compiler.  Its use is not recommended, use the "IF"
macro instead.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_33"><H3>isGreater</H3><BR><BR>
<FONT><B>Purpose:</B> Compares two values to see if the first is greater than the second.</FONT><BR><BR>
<FONT><B>Syntax:</B> isGreater var {value1} {value2} <BR>
<BR>
var: A variable to hold the result of the comparison.<BR>
<BR>
{value1}: A value to compare.<BR>
<BR>
{value2}: A value to be compared with "value1".<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> "var" will be set to TRUE (1) if the first value is greater than the second, or FALSE (0)
if it is not.<BR>
<BR>
This command is used internally by the compiler.  Its use is not recommended, use the "IF"
macro instead.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_34"><H3>isGreaterEqual</H3><BR><BR>
<FONT><B>Purpose:</B> Compares two values to see if the first is greater than or equal to the second.</FONT><BR><BR>
<FONT><B>Syntax:</B> isGreater var {value1} {value2} <BR>
<BR>
var: A variable to hold the result of the comparison.<BR>
<BR>
{value1}: A value to compare.<BR>
<BR>
{value2}: A value to be compared with "value1".</FONT><BR><BR>
<FONT><B>Notes:</B> "var" will be set to TRUE (1) if the first value is greater than or equal to the second, or
FALSE (0) if it is not.<BR>
<BR>
This command is used internally by the compiler.  Its use is not recommended, use the "IF"
macro instead.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_35"><H3>isLesser</H3><BR><BR>
<FONT><B>Purpose:</B> Compares two values to see if the first is less than the second.</FONT><BR><BR>
<FONT><B>Syntax:</B> isLesser var {value1} {value2} <BR>
<BR>
var: A variable to hold the result of the comparison.<BR>
<BR>
{value1}: A value to compare.<BR>
<BR>
{value2}: A value to be compared with "value1".</FONT><BR><BR>
<FONT><B>Notes:</B> "var" will be set to TRUE (1) if the first value is less than the second, or FALSE (0) if
it is not.<BR>
<BR>
This command is used internally by the compiler.  Its use is not recommended, use the "IF"
macro instead.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_36"><H3>isLesserEqual</H3><BR><BR>
<FONT><B>Purpose:</B> Compares two values to see if the first is less than or equal to the second.</FONT><BR><BR>
<FONT><B>Syntax:</B> isLesserEqual var {value1} {value2} <BR>
<BR>
var: A variable to hold the result of the comparison.<BR>
<BR>
{value1}: A value to compare.<BR>
<BR>
{value2}: A value to be compared with "value1".<BR>
{value2}: <BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> "var" will be set to TRUE (1) if the first value is less than or equal to the second, or FALSE
(0) if it is not.<BR>
<BR>
This command is used internally by the compiler.  Its use is not recommended, use the "IF"
macro instead.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_37"><H3>isNotEqual</H3><BR><BR>
<FONT><B>Purpose:</B> Compares two values to see if they are not equal.</FONT><BR><BR>
<FONT><B>Syntax:</B> isNotEqual var {value1} {value2} <BR>
<BR>
var: A variable to hold the result of the comparison.<BR>
<BR>
{value1}: A value to compare.<BR>
<BR>
{value2}: A value to be compared with "value1".<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> "var" will be set to FALSE (0) if the values match, or TRUE (1) if they don't.<BR>
<BR>
This command is used internally by the compiler.  Its use is not recommended, use the "IF"
macro instead.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_38"><H3>isNumber</H3><BR><BR>
<FONT><B>Purpose:</B> Tests a value to see if it is a valid number.</FONT><BR><BR>
<FONT><B>Syntax:</B> isNumber storageVar {value} <BR>
<BR>
storageVar: A variable to hold the result of the test.<BR>
<BR>
{value}: The value to be tested.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> "storageVar" will be set to TRUE (1) if "value" is a number, otherwise it will be set to FALSE
(0).<BR>
<BR>
It is often good practice to test values entered by the user if you expect them to be numeric.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE>:PlanetsPerSector
getInput $value "Enter number of planets per sector"
isNumber $test $value
if ($test = 0)
  echo ANSI_15 "**Value must be a number*"
  goto :PlanetsPerSector
end
setVar $build_planetsPerSector $value
saveVar $build_planetsPerSector

</PRE></FONT><BR><BR><HR>
<A NAME="CMD_39"><H3>killAllTriggers</H3><BR><BR>
<FONT><B>Purpose:</B> Terminates all triggers in the script and its included subroutines.</FONT><BR><BR>
<FONT><B>Syntax:</B> killAllTriggers</FONT><BR><BR>
<FONT><B>Notes:</B> Be careful with this command, especially if you are writing a subroutine that may need to
preserve triggers already existing when the subroutine was called.  It is always better to
specifically terminate triggers using the "killTrigger" command if you know the ones that
are active, instead of just killing all of them.<BR>
<BR>
A good example of where this command could be used is in the disconnection handler of a script.
Scripts should terminate their triggers if they are disconnected from the server, as they
will likely re-enter the game in a completely different state.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_40"><H3>killTrigger</H3><BR><BR>
<FONT><B>Purpose:</B> Terminates a trigger.</FONT><BR><BR>
<FONT><B>Syntax:</B> killTrigger {name} <BR>
<BR>
{name}: The name of a trigger to terminate.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command can be used to terminate any sort of script trigger (TextTrigger, TextLineTrigger,
DelayTrigger, EventTrigger, TextOutTrigger, etc).<BR>
<BR>
If the specified trigger doesn't exist, the script ignores the command and continues as normal.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># see if we have a planet scanner
setVar $scanner 0
send "i"
setTextLineTrigger 1 :HasScanner "Planet Scanner"
setTextTrigger 2 :DoneTest "Command [TL="
pause

:HasScanner
setVar $scanner 1
killTrigger 2

:DoneTest
killTrigger 1</PRE></FONT><BR><BR><HR>
<A NAME="CMD_41"><H3>killWindow</H3><BR><BR>
<FONT><B>Purpose:</B> Unloads a script window.</FONT><BR><BR>
<FONT><B>Syntax:</B> killWindow {windowName} <BR>
<BR>
{windowName}: The name of the window to remove.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command is provided for backwards compatibility.  There is currently no support for script
windows in v2.00.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>

<A NAME="CMD_98"><H3>listActiveScripts</H3><BR><BR>
<FONT><B>Purpose:</B> Populates a user-specified array with a list of currently active scripts.</FONT><BR><BR>
<FONT><B>Syntax:</B> listActiveScripts {ArrayName}</FONT><BR><BR>
<FONT><B>Notes:</B> A variable matching the name of the array will be created to hold the count and size of the array.
So if you named the array $array, then $array will equal the number of active scripts, $array[1] will be the
name of the first script, $array[2] the second, and so on.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># Stop FastFoton.ts if it is running
listActiveScripts $scripts
setVar $a 1
while ($a <= $scripts)
	if ($scripts[$a] = "FastFoton.ts")
		stop $scripts[$a]
		return
	end
	add $a 1
end</PRE></FONT><BR><BR><HR>

<A NAME="CMD_99"><H3>listAvoids</H3><BR><BR>
<FONT><B>Purpose:</B> Populates a user-specified array with the list of sectors currently set on TWX's internal Avoid list.</FONT><BR><BR>
<FONT><B>Syntax:</B> listAvoids {ArrayName}</FONT><BR><BR>
<FONT><B>Notes:</B> A variable matching the name of the array will be created to hold the count and size of the array.
So if you named the array $array, then $array will equal the number of Avoids, $array[1] will be the first avoid, $array[2] the second,
and so on.  Be aware that this is independant from any Avoids set in the game.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># Clear any avoid with our fig present
listAvoids $voids
setVar $a 1
while ($a <= $voids)
	setVar $focus $voids[$a]
	if ($figGrid[$focus] > 0)
		clearAvoid $focus
	end
	add $a 1
end</PRE></FONT><BR><BR><HR>

<A NAME="CMD_100"><H3>listSectorParameters</H3><BR><BR>
<FONT><B>Purpose:</B> Populates a user-specified array with the list of Sector Parameters that exist for the specified sector.</FONT><BR><BR>
<FONT><B>Syntax:</B> listSectorParameters {sector} {ArrayName}</FONT><BR><BR>
<FONT><B>Notes:</B> A variable matching the name of the array will be created to hold the count and size of the array.
So if you named the array $array, then $array will equal the number of Sector Parameters, $array[1] will be the name of the first Sector Parameter,
$array[2] the second, and so on.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># Delete all Sector Parameters from the Database
setVar $a 1
while ($a <= SECTORS)
	listSectorParameters $a $parms
	setVar $b 1
	while ($b <= $parms)
		setSectorParameter $parms[$b] ""
		add $b 1
	end
	add $a 1
end</PRE></FONT><BR><BR><HR>

<A NAME="CMD_42"><H3>load</H3><BR><BR>
<FONT><B>Purpose:</B> Loads a script from a file.</FONT><BR><BR>
<FONT><B>Syntax:</B> load {scriptName} <BR>
<BR>
{scriptName}: The name of a script to load.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This is exactly the same as the $SS TWX Terminal Menu function.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_43"><H3>loadVar</H3><BR><BR>
<FONT><B>Purpose:</B> Loads a variable from a file automatically associated with the currently selected TWX Database.</FONT><BR><BR>
<FONT><B>Syntax:</B> loadVar var <BR>
<BR>
var: The name of a variable to load from file.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command will load a variable from the .cfg file stored in parallel with TWX Proxy's .xdb
files.  It can be used for retrieving variables associated with a script's configuration,
and is a very nice tool for menus.<BR>
<BR>
If the variable is not saved, "var" will be set to "0".</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># get defaults
loadVar $EvilSaved

if ($EvilSaved)
  loadVar $evil_stealFactor
  loadVar $evil_robFactor
  loadVar $evil_continue
  loadVar $evil_broadcast
  loadVar $evil_shipsetup
  loadVar $evil_haggle
else
  setVar $evil_stealFactor 30
  setVar $evil_robFactor 3
  setVar $evil_continue 1
  setVar $evil_broadcast 1
  setVar $evil_shipSetup ""
  setVar $evil_haggle 1

  saveVar $evil_stealFactor
  saveVar $evil_robFactor
  saveVar $evil_continue
  saveVar $evil_broadcast
  saveVar $evil_shipSetup
  saveVar $evil_haggle

  setVar $EvilSaved 1
  saveVar $EvilSaved
end

</PRE></FONT><BR><BR><HR>
<A NAME="CMD_44"><H3>logging</H3><BR><BR>
<FONT><B>Purpose:</B> Disables or enables TWX Proxy's logging feature while the script is running.</FONT><BR><BR>
<FONT><B>Syntax:</B> logging {value} <BR>
<BR>
{value}: The value to define if logging is enabled in the script.  This can be either "ON"
or "OFF".<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> It is good practice to always turn off logging in any script that transfers large amounts
of unnecessary data.<BR>
<BR>
The logging setting is local to every active script.  If there are any scripts running with
it disabled, no data will be logged.  Logging will always default to "ON".</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_45"><H3>lowerCase</H3><BR><BR>
<FONT><B>Purpose:</B> Converts all text within a variable to lower case.</FONT><BR><BR>
<FONT><B>Syntax:</B> lowerCase var <BR>
<BR>
var: A variable containing text to be converted to lower case.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> </FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_46"><H3>mergeText</H3><BR><BR>
<FONT><B>Purpose:</B> Concatenates two text values together to form one.</FONT><BR><BR>
<FONT><B>Syntax:</B> mergeText {value1} {value2} var <BR>
<BR>
{value1}: The value to form the first part of the merged value.<BR>
<BR>
{value2}: The value to form the second part of the merged value.<BR>
<BR>
var: A variable to hold the merged value.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command is used internally by the compiler, its use within scripts is not recommended.
A much more usable way of performing this is through the use of the "&" operator.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_47"><H3>multiply</H3><BR><BR>
<FONT><B>Purpose:</B> Performs mathematical multiplication on a variable.</FONT><BR><BR>
<FONT><B>Syntax:</B> multiply var {value} <BR>
<BR>
var: The variable to be multiplied.<BR>
<BR>
{value}: The amount to multiply the variable by.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command is used internally by the compiler to perform multiplication.  It can also be
called manually.<BR>
<BR>
Another way to perform multiplication is like this:<BR>
<BR>
setVar $value ($value * 50)</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># calculate exactly how many trips we're making
# and how much we're carrying on our last trip

setVar $trips $quantity
divide $trips $holds
setVar $x $trips
multiply $x $holds
setVar $lastTrip $quantity
subtract $lastTrip $x
if ($lastTrip = 0)
  setVar $lastTrip $holds
else
  add $trips 1
end</PRE></FONT><BR><BR><HR>
<A NAME="CMD_48"><H3>openMenu</H3><BR><BR>
<FONT><B>Purpose:</B> Activates an existing script menu or TWX Terminal Menu option.</FONT><BR><BR>
<FONT><B>Syntax:</B> openMenu {name} {pause} <BR>
<BR>
{name}: The name of an existing menu to activate.<BR>
<BR>
{pause}: Optional 2nd parameter, must be 'TRUE' or 'FALSE'.  A Value of 'FALSE' causes the menu to display but not pause.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command will activate (or open) a script or TWX Terminal Menu option.<BR>
<BR>
Menus can be created with the 'addMenu' command, and closed using the 'closeMenu' command.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE>openMenu TWX_LISTACTIVE FALSE

addMenu "" "BuyDown" "BuyDown Settings" "." "" "Main" FALSE
addMenu "BuyDown" "GO" "GO!" "G" :Menu_Go "" TRUE
addMenu "BuyDown" "Product" "Product" "P" :Menu_Product "" FALSE
addMenu "BuyDown" "TurnLimit" "Turn limit" "T" :Menu_TurnLimit "" FALSE
addMenu "BuyDown" "Quantity" "Quantity" "U" :Menu_Quantity "" FALSE
addMenu "BuyDown" "Haggle" "Haggling" "H" :Menu_HaggleFactor "" FALSE

gosub :sub_SetMenu

openMenu "BuyDown"
</PRE></FONT><BR><BR><HR>
<A NAME="CMD_49"><H3>or</H3><BR><BR>
<FONT><B>Purpose:</B> Performs a logical 'OR' on a variable.</FONT><BR><BR>
<FONT><B>Syntax:</B> or var {value} <BR>
<BR>
var: The variable to be operated.  The value in this variable must be either TRUE (1) or FALSE
(0).<BR>
<BR>
{value}: The value to be operated by.  This value must be either TRUE (1) or FALSE (0).<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command is used internally by the compiler to allow conditions to work properly.  Its
use in conventional scripting is almost unheard of.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_50"><H3>pause</H3><BR><BR>
<FONT><B>Purpose:</B> Pauses the script's execution, allowing it to wait for its triggers to activate.</FONT><BR><BR>
<FONT><B>Syntax:</B> pause</FONT><BR><BR>
<FONT><B>Notes:</B> There exist 3 ways to pause a script, these are:<BR>
<BR>
"pause"<BR>
"waitFor"<BR>
"waitOn"<BR>
<BR>
Pause is the most commonly used method.  A script's triggers will not activate unless the
script is paused and waiting.  If a script becomes paused while no triggers are active, it
will hang uselessly.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># see if we have a planet scanner
setVar $scanner 0
send "i"
setTextLineTrigger 1 :HasScanner "Planet Scanner"
setTextTrigger 2 :DoneTest "Command [TL="
pause

:HasScanner
setVar $scanner 1
killTrigger 2

:DoneTest
killTrigger 1</PRE></FONT><BR><BR><HR>
<A NAME="CMD_51"><H3>processIn</H3><BR><BR>
<FONT><B>Purpose:</B> Emulates incoming text from the remote server, activating matching Text and TextLine triggers.</FONT><BR><BR>
<FONT><B>Syntax:</B> processIn processType {text} <BR>
<BR>
processType: The level of which to process the incoming data.  A level of '0' will mean only
triggers within the script can activate - a level of '1' will activate all matching triggers
in ALL scripts.<BR>
<BR>
{text}: The trigger text to emulate.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command is still under development and not completely functional.  Use is not recommended.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_52"><H3>processOut</H3><BR><BR>
<FONT><B>Purpose:</B> Resumes processing out outgoing data that was trapped by a TextOutTrigger.</FONT><BR><BR>
<FONT><B>Syntax:</B> processOut {text} <BR>
<BR>
{text}: The data to process.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> Any outgoing text that is caught by a TextOutTrigger is taken out of the outgoing buffer by
the "getOutText" command.  This command will return it to the buffer so that it can be processed
by other scripts and/or sent to the remote server.<BR>
<BR>
It is often a bad idea to send trapped outgoing data directly to the server using the "send"
command.  This is because in doing so, you prevent any other active scripts from trapping
the same data when it is sent out.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_53"><H3>read</H3><BR><BR>
<FONT><B>Purpose:</B> Reads a line of a text from a text file.</FONT><BR><BR>
<FONT><B>Syntax:</B> read {file} storageVar {line} <BR>
<BR>
{file}: The file to read text from.<BR>
<BR>
storageVar: The variable to store the line in.<BR>
<BR>
{line}: The line number to read.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command attempts to read a line of text from a file.  If the file does not exist, an
error is raised.  If the line is past the end of the file, 'EOF' is returned.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># load bust list
if ($BustFile <> "")
  fileExists $exists $BustFile

  if ($exists)
    setArray $BustList SECTORS
    setVar $i 1
    read $BustFile $bust $i
    while ($bust <> EOF)
      setVar $BustList[$bust] 1
      add $i 1
      read $BustFile $bust $i
    end
  end
end</PRE></FONT><BR><BR><HR>
<A NAME="CMD_90"><H3>readToArray</H3><BR><BR>
<FONT><B>Purpose:</B> Reads a text file directly into a TWX array.</FONT><BR><BR>
<FONT><B>Syntax:</B> readToArray {file} storageArray <BR>
<BR>
{file}: The file to read text from.<BR>
<BR>
storageArray: The TWX Array to store the strings in.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command is especially useful when reading in large text files, especially those greater than 10K lines.  The array will be created and populated in one step.  Any existing array with the same name will first be overwritten.  Also, a variable with the same name as the array will be created, and its integer value will be the the element count of the array.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># Read a text file into an array
readToArray figlist.txt $figArray
# A variable $figArray also exists, and is equal to the element count
echo "*Figged Sectors read:" $figArray
setVar $i 1
while ($i <= $figArray)
	echo "*" $figArray[$i]
	add $i 1
end</PRE></FONT><BR><BR><HR>
<A NAME="CMD_54"><H3>rename</H3><BR><BR>
<FONT><B>Purpose:</B> Renames a file.</FONT><BR><BR>
<FONT><B>Syntax:</B> rename {oldfile} {newfile} <BR>
<BR>
{oldfile}: The file name of the file to rename.<BR>
<BR>
{newfile}: The new name of the renamed file.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command will give a file a new name.  If the file does not exist, or another file exists
under the new name, an error is raised.<BR>
<BR>
To check if a file already exists, use the "fileExists" command.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_55"><H3>replaceText</H3><BR><BR>
<FONT><B>Purpose:</B> Replaces a value, or set of values within a variable.</FONT><BR><BR>
<FONT><B>Syntax:</B> replaceText var {oldText} {newText} <BR>
<BR>
var: A variable containing the text to be replaced.<BR>
<BR>
{oldText}: The text to be replace.<BR>
<BR>
{newText}: The text to replace the old text with.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command will scan through the contents of "var" replacing any text with that which is
specified.<BR>
<BR>
This command is extremely useful when text parsing - you can cut out uncertain characters
in a block of text by converting them to spaces (or nothing), then extract the data you want
using "getWord".</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_56"><H3>reqRecording</H3><BR><BR>
<FONT><B>Purpose:</B> Ensures that data recording is turned ON.</FONT><BR><BR>
<FONT><B>Syntax:</B> reqRecording</FONT><BR><BR>
<FONT><B>Notes:</B> This command will immediately terminate the script with a message if recording is turned off.<BR>
<BR>
It is good practice to always use this command in any script that makes use of the "getSector"
command or interfaces with the TWX Database in any way.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_57"><H3>return</H3><BR><BR>
<FONT><B>Purpose:</B> Return from a subroutine.</FONT><BR><BR>
<FONT><B>Syntax:</B> return</FONT><BR><BR>
<FONT><B>Notes:</B> Use this command to return from a subroutine called by the "gosub" command.<BR>
<BR>
If this command is used from outside a "gosub" subroutine, an error will occur.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># gosub/return demo:

echo "This is a gosub/return demo.  I'm going to branch to a subroutine."
gosub :subroutine
echo "I've just returned from my subroutine"
halt

:subroutine
echo "I'm in my subroutine"
return</PRE></FONT><BR><BR><HR>
<A NAME="CMD_87"><H3>round</H3><BR><BR>
<FONT><B>Purpose:</B> Rounds a variable to the specified precision.</FONT><BR><BR>
<FONT><B>Syntax:</B> round var {precision}</FONT><BR><BR>
<FONT><B>Notes:</B> This command will round the value held in specified variable to a specified number of decimal
places.  It is only really useful when used in combination with the setPrecision command.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE>setPrecision 2
setVar $x "500.52"
round $x 1

# this line will display: 500.5
echo $x</PRE></FONT><BR><BR><HR>
<A NAME="CMD_58"><H3>saveVar</H3><BR><BR>
<FONT><B>Purpose:</B> Saves a variable to a file automatically associated with the currently selected TWX Database.</FONT><BR><BR>
<FONT><B>Syntax:</B> saveVar var <BR>
<BR>
var: The name of a variable to save to file.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command will save a variable to the .cfg file held in parallel with TWX Proxy's .xdb
database files.  Variables can be stored and retreived at any time, but must be under the
same name.<BR>
<BR>
To load a variable, use the "loadVar" command.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># get defaults
loadVar $EvilSaved

if ($EvilSaved)
  loadVar $evil_stealFactor
  loadVar $evil_robFactor
  loadVar $evil_continue
  loadVar $evil_broadcast
  loadVar $evil_shipsetup
  loadVar $evil_haggle
else
  setVar $evil_stealFactor 30
  setVar $evil_robFactor 3
  setVar $evil_continue 1
  setVar $evil_broadcast 1
  setVar $evil_shipSetup ""
  setVar $evil_haggle 1

  saveVar $evil_stealFactor
  saveVar $evil_robFactor
  saveVar $evil_continue
  saveVar $evil_broadcast
  saveVar $evil_shipSetup
  saveVar $evil_haggle

  setVar $EvilSaved 1
  saveVar $EvilSaved
end

</PRE></FONT><BR><BR><HR>
<A NAME="CMD_59"><H3>send</H3><BR><BR>
<FONT><B>Purpose:</B> Sends text to the remote server.</FONT><BR><BR>
<FONT><B>Syntax:</B> send {values...} <BR>
<BR>
{values...}: A series of variables or values to be concatenated and sent to the server.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> </FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_60"><H3>setArray</H3><BR><BR>
<FONT><B>Purpose:</B> Declares a static array.</FONT><BR><BR>
<FONT><B>Syntax:</B> setArray var {dimensions...} <BR>
<BR>
var: A variable to define as an array.<BR>
<BR>
{dimensions...}: A series of values defining the size of the array.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> When a static array is defined, all its values are automatically set to "0".<BR>
<BR>
Static arrays perform MUCH faster than TWX Proxy's dynamic arrays.  Use them whenever possible.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># load bust list
if ($BustFile <> "")
  fileExists $exists $BustFile

  if ($exists)
    setArray $BustList SECTORS
    setVar $i 1
    read $BustFile $bust $i
    while ($bust <> EOF)
      setVar $BustList[$bust] 1
      add $i 1
      read $BustFile $bust $i
    end
  end
end</PRE></FONT><BR><BR><HR>

<A NAME="CMD_101"><H3>setAvoid</H3><BR><BR>
<FONT><B>Purpose:</B> Adds an Avoid to TWX's internal Avoid list.</FONT><BR><BR>
<FONT><B>Syntax:</B> setAvoid {sector}</FONT><BR><BR>
<FONT><B>Notes:</B>  TWX's internal Avoid list is used by getCourse, getDistance, getNearestWarps, and getAllCourses.  These Avoids are
completely independant of the games Avoids.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># One way of showing the backdoor to Stardock
setVar $a 1
while ($a <= SECTOR.WARPCOUNT[STARDOCK])
	# Avoids warps out of StarDock
	setAvoid SECTOR.WARPS[STARDOCK][$a]
	add $a 1
end
getCourse $course 1 STARDOCK
if ($course = 0)
	echo "*No Backdoor found.*"
else
	# $course is the number of hops. Since the $course array
	# is $hops + 1, it is also the next-to-last warp
	echo "*Backdoor: " $course[$course]
end</PRE></FONT><BR><BR><HR>

<A NAME="CMD_61"><H3>setDelayTrigger</H3><BR><BR>
<FONT><B>Purpose:</B> Creates a trigger that will automatically activate after a specified time period.</FONT><BR><BR>
<FONT><B>Syntax:</B> setDelayTrigger {name} {label} {tics} <BR>
<BR>
{name}: The name of the trigger to create.  This name is used for later references to the
trigger.<BR>
<BR>
{label}: A label within the script to jump to when the trigger is activated.<BR>
<BR>
{tics}: The number of milliseconds to wait before the delay trigger automatically activates
itself.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> Triggers mark the way in which TWX Scripts interact with their environment (Trade Wars).<BR>
<BR>
The delay trigger will automatically jump to a label within the script and begin executing
as soon as a certain time period has elapsed.<BR>
<BR>
Note that no triggers will activate unless the script has been paused with a "pause", "waitFor"
or "waitOn" command.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE>:wait
send "#"
setDelayTrigger delay :wait 60000
pause</PRE></FONT><BR><BR><HR>
<A NAME="CMD_62"><H3>setEventTrigger</H3><BR><BR>
<FONT><B>Purpose:</B> Creates a trigger that will activate on a certain program event.</FONT><BR><BR>
<FONT><B>Syntax:</B> setEventTrigger {name} {label} {event} [{parameter}] <BR>
<BR>
{name}: The name of the trigger to create.  This name is used for later references to the
trigger.<BR>
<BR>
{label}: A label within the script to jump to when the trigger is activated.<BR>
<BR>
{event}: The name of the program event to attach the trigger to (see below).<BR>
<BR>
[{parameter}]: Some (but not all) program events require parameters.  These are specified
here.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> Triggers mark the way in which TWX Scripts interact with their environment (Trade Wars).<BR>
<BR>
The event trigger will automatically jump to a label within the script and start executing
as soon as a program event occurs matching its specification.<BR>
<BR>
Currently, TWX Proxy supports the following program events and their parameters:<BR>
<BR>
SCRIPT LOADED : Activates when a script is loaded.  Its parameter is the name of the script
loaded.<BR>
<BR>
SCRIPT STOPPED : Activates when a script is terminated.  Its parameter is the name of the
script terminated.<BR>
<BR>
CONNECTION ACCEPTED : Activates when TWX Proxy connects to the remote server (no parameters).<BR>
<BR>
CONNECTION LOST : Activates when TWX Proxy disconnects from the remote server (no parameters).<BR>
<BR>
CLIENT CONNECTED : Activates when a telnet client connects to TWX Proxy (no parameters).<BR>
<BR>
CLIENT DISCONNECTED : Activates when a telnet client disconnects from TWX Proxy (no parameters).<BR>
<BR>
TIME HIT : Activates when the click hits a certain time.  Its parameter is the specified time
in system format.<BR>
<BR>
<BR>
Note that no triggers will activate unless the script has been paused with a "pause", "waitFor"
or "waitOn" command.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_85"><H3>setMenuHelp</H3><BR><BR>
<FONT><B>Purpose:</B> Sets the help display of an existing menu.</FONT><BR><BR>
<FONT><B>Syntax:</B> setMenuValue {menuName} {value} <BR>
<BR>
{menuName}: The name of the menu to have its value set.<BR>
<BR>
{value}: The new help text for the menu.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command will set the help text displayed when a user requests help on a particular menu
option.  The menu must have been created using the 'addMenu' command, or be a member of the
TWX Terminal Menu.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_64"><H3>setMenuOptions</H3><BR><BR>
<FONT><B>Purpose:</B> Configures standard options accessible from a menu.</FONT><BR><BR>
<FONT><B>Syntax:</B> setMenuOptions {menuName} {Q} {?} {+} <BR>
<BR>
{menuName}: The name of the menu to have its options configured.<BR>
<BR>
{Q}: Defines if the "Exit Menu" function will be accessible from within the specified menu.
Valid options are TRUE (1) and FALSE (0).<BR>
<BR>
{?}: Defines if the "Command List" function will be accessible from within the specified menu.
Valid options are TRUE (1) and FALSE (0).<BR>
<BR>
{+}: Defines if the "Help on Command" function will be accessible from within the specified
menu.  Valid options are TRUE (1) and FALSE (0).<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command can be used to enable or disable the default options supplied to a menu when
it is first created.  By default, all of these options are turned on.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_63"><H3>setMenuValue</H3><BR><BR>
<FONT><B>Purpose:</B> Sets the display value of an existing menu.</FONT><BR><BR>
<FONT><B>Syntax:</B> setMenuValue {menuName} {value} <BR>
<BR>
{menuName}: The name of the menu to have its value set.<BR>
<BR>
{value}: The new value that will be associated with the menu.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command will set the display value of a menu that has either been created using the 'addMenu'
command, or is part of the TWX Terminal Menu.<BR>
<BR>
To get the display value of a menu, use the 'getMenu' command.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE>:sub_SetMenu
  if ($evil_haggle)
    setMenuValue "Haggling" "ON"
  else
    setMenuValue "Haggling" "OFF"
  end

  if ($evil_continue > 0)
    setMenuValue "Continue" "YES"
  else
    setMenuValue "Continue" "NO"
  end

  if ($evil_broadcast > 0)
    setMenuValue "Broadcast" "YES"
  else
    setMenuValue "Broadcast" "NO"
  end

  setMenuValue "StealFactor" $evil_stealFactor
  setMenuValue "RobFactor" $evil_robFactor
  setMenuValue "ShipSetup" $evil_shipSetup
  setMenuValue "QuickSetup" $evil_shipSetup
  return

</PRE></FONT><BR><BR><HR>
<A NAME="CMD_86"><H3>setPrecision</H3><BR><BR>
<FONT><B>Purpose:</B> Sets the maximum precision for decimal calculations.</FONT><BR><BR>
<FONT><B>Syntax:</B> setPrecision {value}<BR>
<BR>
value: The new precision limit for decimals used during script interpretation.<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command is used to enable decimal calculations within TWX script.<BR>
<BR>
By default, the decimal precision within a script is set to 0, this is to maintain backwards
compatibility with older scripts that do not take decimal mathematics into consideration.<BR>
<BR>
TWX Proxy supports decimal precision of up to 20 significant digits from calculations.<BR>
<BR>
Once the precision has been set, all math performed will take into account the new precision
and try to round all resulting values towards it.  There is no limit to the number of times
the precision can be changed within a script - in some cases it can be useful to adjust it
for specific scenarios or subroutines.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># This will set precision to a max of 10 decimal places
setPrecision 10</PRE></FONT><BR><BR><HR>
<A NAME="CMD_65"><H3>setProgVar</H3><BR><BR>
<FONT><B>Purpose:</B> Sets a program variable.</FONT><BR><BR>
<FONT><B>Syntax:</B> setProgVar {varName} {value} <BR>
<BR>
{varName}: The name of the program variable to be set.<BR>
<BR>
{value}: The value to store in the variable.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command is provided for backwards compatibility only.  It has no implementation.  TWX
Proxy v2.00 currently has no support for program variables.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_88"><H3>setSectorParameter</H3><BR><BR>
<FONT><B>Purpose:</B> Sets a permanent variable in the TWX Database, assigning it to a sector.</FONT><BR><BR>
<FONT><B>Syntax:</B> setSectorParameter {sectorIndex} {parameterName} {value}<BR>
<BR>
{sectorIndex}: The index of the sector to hold the value.<BR>
<BR>
{parameterName}: A name identifying the value to allow it to be retrieved later.  This can
be anything up to 10 characters long.<BR>
<BR>
{value}: The value to store.  This can be anything up to 40 characters long.</FONT><BR><BR>
<FONT><B>Notes:</B> Use this command if you need to store an extra sector-specific value in the database (for
example, a notation indicating which sectors belong to an enemy player).<BR>
<BR>
The value assigned to the sector can be any length up to 40 characters.  A sector can in theory
have any number of values assigned to it.  These values can be stored and retrieved from any
script that works using the selected database.<BR>
<BR>
Be extremely careful how many values you store against sectors.  The method used to store
and retrieve these values is not very efficient and will cause performance problems if the
search list of total values is too large.  A large number of these values can also cause the
database to bloat and make it less efficient.<BR>
<BR>
Values can be retrieved using the GetSectorParameter command.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># set the current sector as being enemy territory
setTextLineTrigger getSector :getSector "Sector  : "
pause
:getSector
getWord CURRENTLINE $sector 3
setSectorParameter $sector "Owner" "Enemy"</PRE></FONT><BR><BR><HR>
<A NAME="CMD_66"><H3>setTextLineTrigger</H3><BR><BR>
<FONT><B>Purpose:</B> Creates a trigger that will activate when a full line of text containing a specific value
has been received from the remote server.</FONT><BR><BR>
<FONT><B>Syntax:</B> setTextLineTrigger {name} {label} [{value}] <BR>
<BR>
{name}: The name of the trigger to create.  This name is used for later references to the
trigger.<BR>
<BR>
{label}: A label within the script to jump to when the trigger is activated.<BR>
<BR>
[{value}]: A block of text that is required to be in the line for the trigger to activate.
If this parameter is not specified, the trigger will activate on any line - even if it is
blank.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> Triggers mark the way in which TWX Scripts interact with their environment (Trade Wars).<BR>
<BR>
The TextLine trigger will automatically jump to a label within the script and begin executing
as soon as text is received from the remote server matching a certain requirement.  Note that
this text is case sensitive.<BR>
<BR>
TextLine triggers differ from text triggers in that they will not activate unless a full line
of text has been received.  This makes them the standard for parsing data from the remote
server.<BR>
<BR>
Note that no triggers will activate unless the script has been paused with a "pause", "waitFor"
or "waitOn" command.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># see if we have a planet scanner
setVar $scanner 0
send "i"
setTextLineTrigger 1 :HasScanner "Planet Scanner"
setTextTrigger 2 :DoneTest "Command [TL="
pause

:HasScanner
setVar $scanner 1
killTrigger 2

:DoneTest
killTrigger 1</PRE></FONT><BR><BR><HR>
<A NAME="CMD_67"><H3>setTextOutTrigger</H3><BR><BR>
<FONT><B>Purpose:</B> Creates a trigger that will activate when certain text is received from one of TWX Proxy's
telnet clients.</FONT><BR><BR>
<FONT><B>Syntax:</B> setTextOutTrigger {name} {label} [{value}] <BR>
<BR>
{name}: The name of the trigger to create.  This name is used for later references to the
trigger.<BR>
<BR>
{label}: A label within the script to jump to when the trigger is activated.<BR>
<BR>
[{value}]: A value that must be matched with the outgoing text for the trigger to activate.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> Triggers mark the way in which TWX Scripts interact with their environment (Trade Wars).<BR>
<BR>
The TextOut trigger will automatically jump to a label within the script and begin executing
as soon as text is received from a client terminal containing the specified value.  The outgoing
text will be stored within a buffer and can be retrieved using the "getOutText" command.
After a TextOut trigger has been activated, the original outgoing text is held and will not
be sent until it is passed to a "processOut" command.<BR>
<BR>
Note that no triggers will activate unless the script has been paused with a "pause", "waitFor"
or "waitOn" command.<BR>
</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_68"><H3>setTextTrigger</H3><BR><BR>
<FONT><B>Purpose:</B> Creates a trigger that will activate when a text containing a specific value has been received
from the remote server.</FONT><BR><BR>
<FONT><B>Syntax:</B> setTextTrigger {name} {label} [{value}] <BR>
<BR>
{name}: The name of the trigger to create.  This name is used for later references to the
trigger.<BR>
<BR>
{label}: A label within the script to jump to when the trigger is activated.<BR>
<BR>
[{value}]: A value that is required to be in the block of incoming text for the trigger to
activate.  If this parameter is not specified, the trigger will activate on any line - even
if it is blank.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> Triggers mark the way in which TWX Scripts interact with their environment (Trade Wars).<BR>
<BR>
The Text trigger will automatically jump to a label within the script and begin executing
as soon as text is received from the remote server matching a certain requirement.  Note that
this text is case sensitive.<BR>
<BR>
Because the Text trigger can technically activate when only half a line of text has been received,
it is usually bad practice to use it to extract data from the remote server.  Use a TextLineTrigger
instead.<BR>
<BR>
Note that no triggers will activate unless the script has been paused with a "pause", "waitFor"
or "waitOn" command.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># see if we have a planet scanner
setVar $scanner 0
send "i"
setTextLineTrigger 1 :HasScanner "Planet Scanner"
setTextTrigger 2 :DoneTest "Command [TL="
pause

:HasScanner
setVar $scanner 1
killTrigger 2

:DoneTest
killTrigger 1</PRE></FONT><BR><BR><HR>
<A NAME="CMD_69"><H3>setVar</H3><BR><BR>
<FONT><B>Purpose:</B> Sets the value of a variable.</FONT><BR><BR>
<FONT><B>Syntax:</B> setVar var {value} <BR>
<BR>
var: The name of the variable to set.<BR>
<BR>
{value}: The value to place into the variable.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> </FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># calculate exactly how many trips we're making
# and how much we're carrying on our last trip

setVar $trips $quantity
divide $trips $holds
setVar $x $trips
multiply $x $holds
setVar $lastTrip $quantity
subtract $lastTrip $x
if ($lastTrip = 0)
  setVar $lastTrip $holds
else
  add $trips 1
end</PRE></FONT><BR><BR><HR>
<A NAME="CMD_70"><H3>setWindowContents</H3><BR><BR>
<FONT><B>Purpose:</B> Sets the display content of a script window.</FONT><BR><BR>
<FONT><B>Syntax:</B> setWindowContents {windowName} {value} <BR>
<BR>
{windowName}: The name of the script window to have its contents set.<BR>
<BR>
{value}: The text content to place inside the script window.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> Sets the text content of a script window.  The window must have been created using the 'window'
command.  To allow for multiple lines to be shown in the window, use the "*" value as used
for the send/echo commands.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># Create ZTM progress window - as managed in 1_ZTM.ts
window ztm 170 94 "ZTM" ONTOP
setWindowContents ztm "Perc Done:*Est Time:*Speed:*Up to:"

</PRE></FONT><BR><BR><HR>
<A NAME="CMD_71"><H3>sound</H3><BR><BR>
<FONT><B>Purpose:</B> Plays a sound (.WAV) file.</FONT><BR><BR>
<FONT><B>Syntax:</B> sound {filename} <BR>
<BR>
{filename}: The full relative path and name of a .wav file to play.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> Playing a sound file will temporarily pause script execution - be careful not to play long
sound files in combat situations as this may effect your play.  However, this is a great way
to give warning signals if you are asleep or away from the keyboard.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># play a sound
sound click.wav</PRE></FONT><BR><BR><HR>
<A NAME="CMD_72"><H3>stop</H3><BR><BR>
<FONT><B>Purpose:</B> Terminates an active script.</FONT><BR><BR>
<FONT><B>Syntax:</B> stop {scriptName} <BR>
<BR>
{scriptName}: The file name of the active script to terminate (not case sensitive).<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command will terminate the first script currently being executed by TWX Proxy with a
name that matches the one specified.  The specified script name does not require the extension
(.ts or .cts) of the target script, nor its file path.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># load then terminate keepalive script (completely useless)
load 1_keepalive
stop 1_keepalive</PRE></FONT><BR><BR><HR>
<A NAME="CMD_73"><H3>stripText</H3><BR><BR>
<FONT><B>Purpose:</B> Removes a character or sub-string from a variable.</FONT><BR><BR>
<FONT><B>Syntax:</B> stripText var {value} <BR>
<BR>
var: A variable containing a text value to have certain characters or sub-strings to be removed.<BR>
<BR>
{value}: The character or sub-string to strip from "var".<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command will remove ALL text matching "value" from the specified variable.  This is a
useful way to filter out unnecessary characters if you are trying to extract data from text
received from the remove server.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># stripText example:

setVar $value "This is my value"
stripText $value "my "

# displays: This is value
echo $value</PRE></FONT><BR><BR><HR>
<A NAME="CMD_74"><H3>subtract</H3><BR><BR>
<FONT><B>Purpose:</B> Subtracts a value from a variable.</FONT><BR><BR>
<FONT><B>Syntax:</B> subtract var {value} <BR>
<BR>
var: The variable that will be subtracted from.<BR>
<BR>
{value}: The amount the variable will be subtracted by (must be a number).<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command is a typical way to perform basic mathematics within TWX script.<BR>
<BR>
Since mathematical and logical operators were introduced in v2.00, it is also possible to
subtract from a variable using the following method:<BR>
<BR>
setVar $value ($value - 1)</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># calculate exactly how many trips we're making
# and how much we're carrying on our last trip

setVar $trips $quantity
divide $trips $holds
setVar $x $trips
multiply $x $holds
setVar $lastTrip $quantity
subtract $lastTrip $x
if ($lastTrip = 0)
  setVar $lastTrip $holds
else
  add $trips 1
end</PRE></FONT><BR><BR><HR>
<A NAME="CMD_79"><H3>systemScript</H3><BR><BR>
<FONT><B>Purpose:</B> Sets the script to become a "systemScript", allowing it to run in the background without the
ability for it to be quick-terminated.</FONT><BR><BR>
<FONT><B>Syntax:</B> systemScript</FONT><BR><BR>
<FONT><B>Notes:</B> System scripts cannot be terminated by the "Stop all scripts" TWX Terminal Menu options.
This makes them useful as keepalive, control or monitor scripts.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_80"><H3>upperCase</H3><BR><BR>
<FONT><B>Purpose:</B> Converts all text within a variable to upper case.</FONT><BR><BR>
<FONT><B>Syntax:</B> upperCase var <BR>
<BR>
var: A variable containing the text to be converted to upper-case.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> </FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_81"><H3>waitFor</H3><BR><BR>
<FONT><B>Purpose:</B> Pauses script execution, waiting for a certain string of text from the remote server before
continuing.</FONT><BR><BR>
<FONT><B>Syntax:</B> waitFor {value} <BR>
<BR>
{value}: The value to wait for.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> If a trigger activates while this command is active, the command is immediately forgotten.<BR>
<BR>
There is no reason why this command should be used instead of a trigger, except for the fact
that it is easier to manage.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE>waitfor "(ENTER for none):"
send LoginName "*"
waitfor "Trade Wars 2002 Game Server"
send Game
waitfor "module now loading."
send "*t***" Password "*"
</PRE></FONT><BR><BR><HR>
<A NAME="CMD_82"><H3>window</H3><BR><BR>
<FONT><B>Purpose:</B> Creates a script window to display information while the script is running.</FONT><BR><BR>
<FONT><B>Syntax:</B> window {windowName} {sizeX} {sizeY} {title} [{ontop}] <BR>
<BR>
{windowName}: The name of the script window to create.  The window will in future be referenced
by this name.<BR>
<BR>
{sizeX}: The width (in pixels) of the new window.<BR>
<BR>
{sizeY}: The height (in pixels) of the new window.<BR>
<BR>
{title}: The title to display at the top of the window.<BR>
<BR>
[{ontop}]: If specified, the window will be set to appear on top of all other windows on the
desktop.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This is a very useful way to get information back from an active script without needing to
dump it into a scrolling terminal.  An example would be progress reports from a ZTM script.<BR>
<BR>
Once a window has been created, its content can be modified with the 'setWindowContents' command.
Terminating the script will automatically close the window.<BR>
<BR>
Note that if you use of the "*" character in the window contents will create a new line in
the window.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE># Create ZTM progress window - as managed in 1_ZTM.ts
window ztm 170 94 "ZTM" ONTOP
setWindowContents ztm "Perc Done:*Est Time:*Speed:*Up to:"

</PRE></FONT><BR><BR><HR>
<A NAME="CMD_83"><H3>write</H3><BR><BR>
<FONT><B>Purpose:</B> Appends a line of text to a text file.</FONT><BR><BR>
<FONT><B>Syntax:</B> write {file} {value} <BR>
<BR>
{file}: The name of a text file to append a line to.<BR>
<BR>
{value}: The value to append to the file.<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command can be used to store a line of text at the end of a file.  If the file does not
exist, it is created.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<A NAME="CMD_84"><H3>xor</H3><BR><BR>
<FONT><B>Purpose:</B> Performs a logical 'XOR' on a variable.</FONT><BR><BR>
<FONT><B>Syntax:</B> xor var {value} <BR>
<BR>
var: The variable to be operated.  The value in this variable must be either TRUE (1) or FALSE
(0).<BR>
<BR>
{value}: The value to be operated by.  This value must be either TRUE (1) or FALSE (0).<BR>
<BR>
</FONT><BR><BR>
<FONT><B>Notes:</B> This command is used internally by the compiler to allow conditions to work properly.  Its
use in conventional scripting is almost unheard of.</FONT><BR><BR>
<FONT><B>Example:</B><BR><BR><PRE></PRE></FONT><BR><BR><HR>
<CENTER><H2>Script Macros</H2></CENTER><HR>
<A NAME="MACRO_62"><H3>IF</H3><BR><BR>
<PRE>Usage:

IF (expression)
  ...
ELSEIF
  ...
ELSE
  ...
END


Description:

This macro will write micro-commands to perform a standard 'if' comparison.  All the commands
under the 'IF' section of this structure will only be executed if the expression evaluates
to true.  The commands under the 'ELSEIF' will only be executed if the primary expression
results to false, and 'ELSEIF' expression results to true.  The commands under the 'ELSE'
structure will only be executed if no other part of the structure has been.


Example:

IF ($x = "Hello")
  echo "Hello there!"
ELSEIF ($x = "Bye")
  echo "Bye!"
ELSE
  echo "I didn't hear you!"
END</PRE><BR><BR><HR>
<A NAME="MACRO_63"><H3>INCLUDE</H3><BR><BR>
<PRE>Usage:

INCLUDE scriptname


Description:

This macro will include the code from another script or pack2 include file during compilation.


Example:

include "includemove"</PRE><BR><BR><HR>
<A NAME="MACRO_64"><H3>WAITON</H3><BR><BR>
<PRE>Usage:

WAITON text


Description:

This macro will write the commands to create a temporary TextTrigger.  This can be used as
a substitute for a waitFor command that will not be 'broken' if another trigger activates
while the script is waiting for text.


Example:

waitOn "Command [TL="</PRE><BR><BR><HR>
<A NAME="MACRO_61"><H3>WHILE</H3><BR><BR>
<PRE>Usage:

WHILE (expression)
  ...
END


Description:  This macro will create a standard 'while' loop.  All the commands within this
loop will continue to be repeated until the expression evaluates to false.


Example:

setVar $x 1
WHILE ($x < 10)
  echo "Counting: " & $x & "*"
  add $x 1
END</PRE><BR><BR><HR>
</BODY>
</HTML>
<CENTER><H2>System Values</H2></CENTER><HR>
<A NAME="VAL_123"><H3>ALPHACENTAURI</H3><BR><BR>
<PRE>Returns the sector in which the Class 0 - Alpha Centauri was last sighted.</PRE><BR><BR><HR>
<A NAME="VAL_1"><H3>ANSI_0</H3><BR><BR>
<PRE>Returns the ANSI code for the colour black.</PRE><BR><BR><HR>
<A NAME="VAL_2"><H3>ANSI_1</H3><BR><BR>
<PRE>Returns the ANSI code for the colour dark blue.</PRE><BR><BR><HR>
<A NAME="VAL_11"><H3>ANSI_10</H3><BR><BR>
<PRE>Returns the ANSI code for the colour light green.</PRE><BR><BR><HR>
<A NAME="VAL_12"><H3>ANSI_11</H3><BR><BR>
<PRE>Returns the ANSI code for the colour light cyan.</PRE><BR><BR><HR>
<A NAME="VAL_13"><H3>ANSI_12</H3><BR><BR>
<PRE>Returns the ANSI code for the colour light red.</PRE><BR><BR><HR>
<A NAME="VAL_14"><H3>ANSI_13</H3><BR><BR>
<PRE>Returns the ANSI code for the colour light purple.</PRE><BR><BR><HR>
<A NAME="VAL_15"><H3>ANSI_14</H3><BR><BR>
<PRE>Returns the ANSI code for the colour light yellow.</PRE><BR><BR><HR>
<A NAME="VAL_16"><H3>ANSI_15</H3><BR><BR>
<PRE>Returns the ANSI code for the colour white.</PRE><BR><BR><HR>
<A NAME="VAL_3"><H3>ANSI_2</H3><BR><BR>
<PRE>Returns the ANSI code for the colour dark green.</PRE><BR><BR><HR>
<A NAME="VAL_4"><H3>ANSI_3</H3><BR><BR>
<PRE>Returns the ANSI code for the colour dark cyan.</PRE><BR><BR><HR>
<A NAME="VAL_5"><H3>ANSI_4</H3><BR><BR>
<PRE>Returns the ANSI code for the colour dark red.</PRE><BR><BR><HR>
<A NAME="VAL_6"><H3>ANSI_5</H3><BR><BR>
<PRE>Returns the ANSI code for the colour dark purple.</PRE><BR><BR><HR>
<A NAME="VAL_7"><H3>ANSI_6</H3><BR><BR>
<PRE>Returns the ANSI code for the colour dark yellow.</PRE><BR><BR><HR>
<A NAME="VAL_8"><H3>ANSI_7</H3><BR><BR>
<PRE>Returns the ANSI code for the colour grey.</PRE><BR><BR><HR>
<A NAME="VAL_9"><H3>ANSI_8</H3><BR><BR>
<PRE>Returns the ANSI code for the colour dark grey.</PRE><BR><BR><HR>
<A NAME="VAL_10"><H3>ANSI_9</H3><BR><BR>
<PRE>Returns the ANSI code for the colour light blue.</PRE><BR><BR><HR>
<A NAME="VAL_17"><H3>CONNECTED</H3><BR><BR>
<PRE>Returns TRUE (1) if TWX Proxy is connected to the remote server, or FALSE (0) if it is not.</PRE><BR><BR><HR>
<A NAME="VAL_18"><H3>CURRENTANSILINE</H3><BR><BR>
<PRE>Returns the current line of text that is partway through processing, complete with any ANSI
codes in it.</PRE><BR><BR><HR>
<A NAME="VAL_121"><H3>CURRENTLINE</H3><BR><BR>
<PRE>Returns the current line being processed from the game server.  In a normal situation, this
is the line that has just been triggered on.</PRE><BR><BR><HR>
<A NAME="VAL_124"><H3>CURRENTSECTOR</H3><BR><BR>
<PRE>Returns the current sector as last seen at the Command prompt or Computer Command prompt.</PRE><BR><BR><HR>
<A NAME="VAL_19"><H3>DATE</H3><BR><BR>
<PRE>Returns the current date in system format.</PRE><BR><BR><HR>
<A NAME="VAL_20"><H3>FALSE</H3><BR><BR>
<PRE>Returns "0".</PRE><BR><BR><HR>
<A NAME="VAL_21"><H3>GAME</H3><BR><BR>
<PRE>Returns the game letter as stored in the currently selected database.  This is usually used
by login scripts.</PRE><BR><BR><HR>
<A NAME="VAL_22"><H3>GAMENAME</H3><BR><BR>
<PRE>Returns the name of the currently selected database.</PRE><BR><BR><HR>
<A NAME="VAL_23"><H3>LICENSENAME</H3><BR><BR>
<PRE>Returns the user portion of the current registration.</PRE><BR><BR><HR>
<A NAME="VAL_24"><H3>LOGINNAME</H3><BR><BR>
<PRE>Returns the login name as stored in the currently selected database.  This is usually used
by login scripts.</PRE><BR><BR><HR>
<A NAME="VAL_25"><H3>PASSWORD</H3><BR><BR>
<PRE>Returns the user password as stored in the currently selected database.  This is usually used
by login scripts.</PRE><BR><BR><HR>
<A NAME="VAL_125"><H3>PORT.BUILDTIME[sector]</H3><BR><BR>
<PRE>Returns the number of days remaining until port completion.  This figure is not updated, so
the SECTOR.UPDATED timestamp should be used as a reference.</PRE><BR><BR><HR>
<A NAME="VAL_29"><H3>PORT.BUYEQUIP[sector]</H3><BR><BR>
<PRE>Returns TRUE (1) if the port in the specified sector buys equipment, or FALSE (0) if it does
not.</PRE><BR><BR><HR>
<A NAME="VAL_27"><H3>PORT.BUYFUEL[sector]</H3><BR><BR>
<PRE>Returns TRUE (1) if the port in the specified sector buys fuel ore, or FALSE (0) if it does
not.</PRE><BR><BR><HR>
<A NAME="VAL_28"><H3>PORT.BUYORG[sector]</H3><BR><BR>
<PRE>Returns TRUE (1) if the port in the specified sector buys organics, or FALSE (0) if it does
not.</PRE><BR><BR><HR>
<A NAME="VAL_26"><H3>PORT.CLASS[sector]</H3><BR><BR>
<PRE>Returns the class of a port within a particular sector as stored in the TWX Proxy Database.</PRE><BR><BR><HR>
<A NAME="VAL_32"><H3>PORT.EQUIP[sector]</H3><BR><BR>
<PRE>Returns the amount of onhand equipment in a port in a specified sector, as stored in the TWX
Proxy Database.</PRE><BR><BR><HR>
<A NAME="VAL_120"><H3>PORT.EXISTS[sector]</H3><BR><BR>
<PRE>Returns TRUE (1) if a port exists in the specified sector, or FALSE (0) if it doesn't.</PRE><BR><BR><HR>
<A NAME="VAL_30"><H3>PORT.FUEL[sector]</H3><BR><BR>
<PRE>Returns the amount of onhand fuel in a port in a specified sector, as stored in the TWX Proxy
Database.</PRE><BR><BR><HR>
<A NAME="VAL_119"><H3>PORT.NAME[sector]</H3><BR><BR>
<PRE>Returns the name of the port in the specified sector.</PRE><BR><BR><HR>
<A NAME="VAL_31"><H3>PORT.ORG[sector]</H3><BR><BR>
<PRE>Returns the amount of onhand organics in a port in a specified sector, as stored in the TWX
Proxy Database.</PRE><BR><BR><HR>
<A NAME="VAL_35"><H3>PORT.PERCENTEQUIP[sector]</H3><BR><BR>
<PRE>Returns the onhand percentage of the maximum available equipment on a port, as stored in the
TWX Proxy Database.</PRE><BR><BR><HR>
<A NAME="VAL_33"><H3>PORT.PERCENTFUEL[sector]</H3><BR><BR>
<PRE>Returns the onhand percentage of the maximum available fuel on a port, as stored in the TWX
Proxy Database.</PRE><BR><BR><HR>
<A NAME="VAL_34"><H3>PORT.PERCENTORG[sector]</H3><BR><BR>
<PRE>Returns the onhand percentage of the maximum available organics on a port, as stored in the
TWX Proxy Database.</PRE><BR><BR><HR>
<A NAME="VAL_126"><H3>PORT.UPDATED[sector]</H3><BR><BR>
<PRE>Returns the date and timestamp that a port was last updated in the database.</PRE><BR><BR><HR>
<A NAME="VAL_127"><H3>RAWPACKET</H3><BR><BR>
<PRE>Returns the unaltered data received in the last transmission from the server.</PRE><BR><BR><HR>
<A NAME="VAL_122"><H3>RYLOS</H3><BR><BR>
<PRE>Returns the sector in which the Class 0 - Rylos was last sighted.</PRE><BR><BR><HR>
<A NAME="VAL_118"><H3>SECTOR.ANOMOLY[sector]</H3><BR><BR>
<PRE>Returns 1 (TRUE) if a sector was last recorded with an anomoly, or 0 (FALSE) if it wasn't.</PRE><BR><BR><HR>
<A NAME="VAL_36"><H3>SECTOR.BACKDOORCOUNT[sector]</H3><BR><BR>
<PRE>Returns the number of one-way warps (backdoors) leading into a specific sector.</PRE><BR><BR><HR>
<A NAME="VAL_37"><H3>SECTOR.BACKDOORS[sector][index]</H3><BR><BR>
<PRE>Returns a particular one-way warp (backdoor) into a specific sector.  There can be up to SECTOR.BACKDOORCOUNT[sector]
backdoors leading into one sector.</PRE><BR><BR><HR>
<A NAME="VAL_128"><H3>SECTOR.BEACON[sector]</H3><BR><BR>
<PRE>Returns the name of the Beacon in the sector, if present.</PRE><BR><BR><HR>
<A NAME="VAL_129"><H3>SECTOR.CONSTELLATION[sector]</H3><BR><BR>
<PRE>Returns the name of the nebulae of which the sector is a part.</PRE><BR><BR><HR>
<A NAME="VAL_38"><H3>SECTOR.DENSITY[sector]</H3><BR><BR>
<PRE>Returns the density reading for a specific sector as stored in the TWX Proxy Database.</PRE><BR><BR><HR>
<A NAME="VAL_39"><H3>SECTOR.EXPLORED[sector]</H3><BR><BR>
<PRE>Returns the explored status of a specific sector as stored in the TWX Proxy Database.  This
can be any one of the following:
"YES" : The sector has been seen with a holoscanner, a probe, or in person.
"DENSITY" : The sector has been seen with a density scanner only.
"CALC" : The sector has not been seen, but at least one warp has been calculated out of it
(ZTM).
"NO": The sector has not been explored or calculated in any way.</PRE><BR><BR><HR>
<A NAME="VAL_40"><H3>SECTOR.FIGS.OWNER[sector]</H3><BR><BR>
<PRE>Returns the name of the owner of a group of fighters in a specific sector as stored in the
TWX Proxy Database.</PRE><BR><BR><HR>
<A NAME="VAL_41"><H3>SECTOR.FIGS.QUANTITY[sector]</H3><BR><BR>
<PRE>Returns the number of fighters in a specific sector as stored in the TWX Proxy Database.</PRE><BR><BR><HR>
<A NAME="VAL_130"><H3>SECTOR.FIGS.TYPE[sector]</H3><BR><BR>
<PRE>Returns the type of fighter present in the sector: Offensive, Defensive, or Toll.</PRE><BR><BR><HR>
<A NAME="VAL_42"><H3>SECTOR.LIMPETS.OWNER[sector]</H3><BR><BR>
<PRE>Returns the owner of the limpet mines in a specific sector as stored in the TWX Proxy Database.</PRE><BR><BR><HR>
<A NAME="VAL_43"><H3>SECTOR.LIMPETS.QUANTITY[sector]</H3><BR><BR>
<PRE>Returns the number of limpet mines in a specific sector as stored in the TWX Proxy Database.</PRE><BR><BR><HR>
<A NAME="VAL_44"><H3>SECTOR.MINES.OWNER[sector]</H3><BR><BR>
<PRE>Returns the owner of armid mines in a specific sector as stored in the TWX Proxy Database.</PRE><BR><BR><HR>
<A NAME="VAL_45"><H3>SECTOR.MINES.QUANTITY[sector]</H3><BR><BR>
<PRE>Returns the number of armid mines in a sector as stored in the TWX Proxy Database.</PRE><BR><BR><HR>
<A NAME="VAL_46"><H3>SECTOR.NAVHAZ[sector]</H3><BR><BR>
<PRE>Returns the amount of navigational hazard in a sector as stored in the TWX Proxy Database.</PRE><BR><BR><HR>
<A NAME="VAL_47"><H3>SECTOR.PLANETCOUNT[sector]</H3><BR><BR>
<PRE>Returns the number of planets in a specific sector as stored in the TWX Proxy Database.</PRE><BR><BR><HR>
<A NAME="VAL_48"><H3>SECTOR.PLANETS[sector][index]</H3><BR><BR>
<PRE>Returns the name of a specific planet in a specific sector, as stored in the TWX Proxy Database.</PRE><BR><BR><HR>
<A NAME="VAL_49"><H3>SECTOR.SHIPCOUNT[sector]</H3><BR><BR>
<PRE>Returns the number of ships in a specific sector as stored in the TWX Proxy Database.</PRE><BR><BR><HR>
<A NAME="VAL_51"><H3>SECTOR.SHIPS[sector][index]</H3><BR><BR>
<PRE>Returns the name of a specific ship within a specific sector as stored in the TWX Proxy Database.</PRE><BR><BR><HR>
<A NAME="VAL_50"><H3>SECTOR.TRADERCOUNT[sector]</H3><BR><BR>
<PRE>Returns the number of traders in a specific sector as stored in the TWX Proxy Database.</PRE><BR><BR><HR>
<A NAME="VAL_52"><H3>SECTOR.TRADERS[sector][index]</H3><BR><BR>
<PRE>Returns the name of a specific trader within a specific sector as stored within the TWX Proxy
Database.</PRE><BR><BR><HR>
<A NAME="VAL_117"><H3>SECTOR.UPDATED[sector]</H3><BR><BR>
<PRE>Returns the date and timestamp that a sector was last updated in the database.</PRE><BR><BR><HR>
<A NAME="VAL_53"><H3>SECTOR.WARPCOUNT[sector]</H3><BR><BR>
<PRE>Returns the number of warps leading out of a specific sector as stored in the TWX Proxy Database.</PRE><BR><BR><HR>
<A NAME="VAL_56"><H3>SECTOR.WARPINCOUNT[sector]</H3><BR><BR>
<PRE>Returns the number of warps leading into a specific sector as stored in the TWX Proxy Database.</PRE><BR><BR><HR>
<A NAME="VAL_55"><H3>SECTOR.WARPSIN[sector][index]</H3><BR><BR>
<PRE>Returns a particular warp leading into a specific sector as stored in the TWX Proxy Database.</PRE><BR><BR><HR>
<A NAME="VAL_54"><H3>SECTOR.WARPS[sector][index]</H3><BR><BR>
<PRE>Returns a particular warp leading out of a specific sector as stored in the TWX Proxy Database.</PRE><BR><BR><HR>
<A NAME="VAL_57"><H3>SECTORS</H3><BR><BR>
<PRE>Returns the number of sectors in the currently selected database.</PRE><BR><BR><HR>
<A NAME="VAL_58"><H3>STARDOCK</H3><BR><BR>
<PRE>Returns the sector in which the game's stardock was last sighted.</PRE><BR><BR><HR>
<A NAME="VAL_59"><H3>TIME</H3><BR><BR>
<PRE>Returns the current time in system format.</PRE><BR><BR><HR>
<A NAME="VAL_60"><H3>TRUE</H3><BR><BR>
<PRE>Returns "1".</PRE><BR><BR><HR>
</BODY>
</HTML>
<CENTER><H2>Terminal Menu References</H2></CENTER><HR>
<A NAME="MENU_78"><H3>TWX_ACCEPTEXTERNAL</H3><BR><BR>
<PRE>Represents the option to control external connections in the TWX setup menu.</PRE><BR><BR><HR>
<A NAME="MENU_74"><H3>TWX_BUBBLESIZE</H3><BR><BR>
<PRE>Represents the option to adjust the maximum bubble size in the TWX setup menu.</PRE><BR><BR><HR>
<A NAME="MENU_81"><H3>TWX_BURST</H3><BR><BR>
<PRE>Represents the burst option in the main TWX Terminal Menu.</PRE><BR><BR><HR>
<A NAME="MENU_79"><H3>TWX_CACHE</H3><BR><BR>
<PRE>Represents the option to enable or disable the database cache, in the TWX setup menu.</PRE><BR><BR><HR>
<A NAME="MENU_84"><H3>TWX_CONNECT</H3><BR><BR>
<PRE>Represents the connect/disconnect option in the main TWX Terminal Menu.</PRE><BR><BR><HR>
<A NAME="MENU_67"><H3>TWX_DATA</H3><BR><BR>
<PRE>Represents the TWX data menu.</PRE><BR><BR><HR>
<A NAME="MENU_70"><H3>TWX_DATABASE</H3><BR><BR>
<PRE>Represents the TWX database setup menu.</PRE><BR><BR><HR>
<A NAME="MENU_112"><H3>TWX_DATABASE_CREATE</H3><BR><BR>
<PRE>Represents the option to a create a TWX database, in the TWX database setup menu.</PRE><BR><BR><HR>
<A NAME="MENU_114"><H3>TWX_DATABASE_DELETE</H3><BR><BR>
<PRE>Represents the option to delete an existing TWX database, in the TWX database setup menu.</PRE><BR><BR><HR>
<A NAME="MENU_113"><H3>TWX_DATABASE_EDIT</H3><BR><BR>
<PRE>Represents the option to edit an existing database, in the TWX database setup menu.</PRE><BR><BR><HR>
<A NAME="MENU_115"><H3>TWX_DATABASE_SELECT</H3><BR><BR>
<PRE>Represents the option to select a specific database, in the TWX database setup menu.</PRE><BR><BR><HR>
<A NAME="MENU_116"><H3>TWX_DATABASE_VIEW</H3><BR><BR>
<PRE>Represents the option to view the details of a specific database, in the TWX database setup
menu.</PRE><BR><BR><HR>
<A NAME="MENU_92"><H3>TWX_DUMPSCRIPTVARS</H3><BR><BR>
<PRE>Represents the option to dump a list of all variables in use in every active script, in the
TWX script menu.</PRE><BR><BR><HR>
<A NAME="MENU_83"><H3>TWX_EDITBURST</H3><BR><BR>
<PRE>Represents the edit burst option in the main TWX Terminal Menu.</PRE><BR><BR><HR>
<A NAME="MENU_88"><H3>TWX_EXIT</H3><BR><BR>
<PRE>Represents the option to immediately terminate the program, in the main TWX Terminal Menu.</PRE><BR><BR><HR>
<A NAME="MENU_103"><H3>TWX_HOLOSCAN</H3><BR><BR>
<PRE>Represents the option to simulate a holoscan, in the TWX data menu.</PRE><BR><BR><HR>
<A NAME="MENU_95"><H3>TWX_KILL</H3><BR><BR>
<PRE>Represents the option to terminate a specific script, in the TWX script menu.</PRE><BR><BR><HR>
<A NAME="MENU_93"><H3>TWX_LISTACTIVE</H3><BR><BR>
<PRE>Represents the option to list all active scripts, in the TWX script menu.</PRE><BR><BR><HR>
<A NAME="MENU_94"><H3>TWX_LISTDIRECTORY</H3><BR><BR>
<PRE>Represents the option to list all the scripts in the script directory, in the TWX script menu.</PRE><BR><BR><HR>
<A NAME="MENU_73"><H3>TWX_LISTENPORT</H3><BR><BR>
<PRE>Represents the option to configure the listening port in the TWX setup menu.</PRE><BR><BR><HR>
<A NAME="MENU_110"><H3>TWX_LISTPORTS</H3><BR><BR>
<PRE>Represents the option to list all recorded ports, in the TWX port menu.</PRE><BR><BR><HR>
<A NAME="MENU_111"><H3>TWX_LISTUPGRADEDPORTS</H3><BR><BR>
<PRE>Represents the option to list all upgraded ports, in the TWX port menu.</PRE><BR><BR><HR>
<A NAME="MENU_90"><H3>TWX_LOADLASTSCRIPT</H3><BR><BR>
<PRE>Represents the option to load the last loaded script, in the TWX script menu.</PRE><BR><BR><HR>
<A NAME="MENU_89"><H3>TWX_LOADSCRIPT</H3><BR><BR>
<PRE>Represents the option to load a script, in the TWX script menu.</PRE><BR><BR><HR>
<A NAME="MENU_80"><H3>TWX_LOCALECHO</H3><BR><BR>
<PRE>Represents the option to enable or disable local echoing of outgoing data, in the TWX setup
menu.</PRE><BR><BR><HR>
<A NAME="MENU_76"><H3>TWX_LOG</H3><BR><BR>
<PRE>Represents the option to enable or disable the logging of data received from the remote server,
in the TWX setup menu.</PRE><BR><BR><HR>
<A NAME="MENU_77"><H3>TWX_LOGANSI</H3><BR><BR>
<PRE>Represents the option to log ANSI codes in the TWX setup menu.</PRE><BR><BR><HR>
<A NAME="MENU_65"><H3>TWX_MAIN</H3><BR><BR>
<PRE>Represents the main TWX Terminal Menu.</PRE><BR><BR><HR>
<A NAME="MENU_102"><H3>TWX_PLOTCOURSE</H3><BR><BR>
<PRE>Represents the option to plot a warp course between two sectors, in the TWX data menu.</PRE><BR><BR><HR>
<A NAME="MENU_68"><H3>TWX_PORT</H3><BR><BR>
<PRE>Represents the TWX port menu.</PRE><BR><BR><HR>
<A NAME="MENU_75"><H3>TWX_RECONNECT</H3><BR><BR>
<PRE>Represents the option to enable or disable automatic reconnection to the remote server, in
the TWX setup menu.</PRE><BR><BR><HR>
<A NAME="MENU_82"><H3>TWX_REPEATBURST</H3><BR><BR>
<PRE>Represents the repeat burst option in the main TWX Terminal Menu.</PRE><BR><BR><HR>
<A NAME="MENU_66"><H3>TWX_SCRIPT</H3><BR><BR>
<PRE>Represents the TWX script menu.</PRE><BR><BR><HR>
<A NAME="MENU_72"><H3>TWX_SCRIPTKEY</H3><BR><BR>
<PRE>Represents the script menu created by the getConsoleInput command for single-key input.  For
internal use only - DO NOT open this menu.</PRE><BR><BR><HR>
<A NAME="MENU_71"><H3>TWX_SCRIPTTEXT</H3><BR><BR>
<PRE>Represents an open menu created by the getInput or getConsoleInput command.  This is for internal
use only - DO NOT open this menu.</PRE><BR><BR><HR>
<A NAME="MENU_69"><H3>TWX_SETUP</H3><BR><BR>
<PRE>Represents the TWX setup menu.</PRE><BR><BR><HR>
<A NAME="MENU_100"><H3>TWX_SHOWANOM</H3><BR><BR>
<PRE>Represents the option to show all sectors with a reported anomoly, in the TWX data menu.</PRE><BR><BR><HR>
<A NAME="MENU_107"><H3>TWX_SHOWBACKDOORS</H3><BR><BR>
<PRE>Represents the option to display backdoors to a specific sector, in the TWX data menu.</PRE><BR><BR><HR>
<A NAME="MENU_106"><H3>TWX_SHOWBUBBLE</H3><BR><BR>
<PRE>Represents the option to calculate and display a specific bubble, in the TWX data menu.</PRE><BR><BR><HR>
<A NAME="MENU_105"><H3>TWX_SHOWBUBBLES</H3><BR><BR>
<PRE>Represents the option to calculate and show bubbles, in the TWX data menu.</PRE><BR><BR><HR>
<A NAME="MENU_87"><H3>TWX_SHOWCLIENTS</H3><BR><BR>
<PRE>Represents the option to display all connected clients, in the main TWX Terminal Menu.</PRE><BR><BR><HR>
<A NAME="MENU_99"><H3>TWX_SHOWDENSITY</H3><BR><BR>
<PRE>Represents the option to show all sectors within a density range, in the TWX data menu.</PRE><BR><BR><HR>
<A NAME="MENU_97"><H3>TWX_SHOWFIGS</H3><BR><BR>
<PRE>Represents the option to show all sectors with foreign fighters in them, in the TWX data menu.</PRE><BR><BR><HR>
<A NAME="MENU_98"><H3>TWX_SHOWMINES</H3><BR><BR>
<PRE>Represents the option to show all sectors with mines in them, in the TWX data menu.</PRE><BR><BR><HR>
<A NAME="MENU_108"><H3>TWX_SHOWPORT</H3><BR><BR>
<PRE>Represents the option to display a specific port, in the TWX port menu.</PRE><BR><BR><HR>
<A NAME="MENU_96"><H3>TWX_SHOWSECTOR</H3><BR><BR>
<PRE>Represents the option to display a specific sector, in the TWX data menu.</PRE><BR><BR><HR>
<A NAME="MENU_109"><H3>TWX_SHOWSPECIALPORT</H3><BR><BR>
<PRE>Represents the option to display all class 0/9 ports, in the TWX port menu.</PRE><BR><BR><HR>
<A NAME="MENU_101"><H3>TWX_SHOWTRADERS</H3><BR><BR>
<PRE>Represents the option to show all sectors with traders in them, in the TWX data menu.</PRE><BR><BR><HR>
<A NAME="MENU_91"><H3>TWX_STOPALL</H3><BR><BR>
<PRE>Represents the option to terminate all active scripts, in the TWX script menu.</PRE><BR><BR><HR>
<A NAME="MENU_86"><H3>TWX_STOPALLFAST</H3><BR><BR>
<PRE>Represents the 'stop all scripts' option in the main TWX Terminal Menu.</PRE><BR><BR><HR>
<A NAME="MENU_85"><H3>TWX_TOGGLEDEAF</H3><BR><BR>
<PRE>Represents the toggle deaf client function in the main TWX Terminal Menu.</PRE><BR><BR><HR>
<A NAME="MENU_104"><H3>TWX_TOTALSCANNED</H3><BR><BR>
<PRE>Represents the option to display a summary of all sectors scanned, in the TWX data menu.</PRE><BR><BR><HR>
</BODY>
</HTML>
